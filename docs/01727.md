# DevOps 和自动化抽象？

> 原文:[https://devops.com/devops-automation-abstraction/](https://devops.com/devops-automation-abstraction/)

相似性孕育着一致性，让位于可预测性，从而通过减少事故数量和缩短解决时间来降低运营成本和质量。但是这一连串事件的核心是认识到我们倾向于用同样的方式，一遍又一遍地，为一种给定的技术做某些任务。可变性成为我们的敌人。一致性成为我们的盟友。因此，问题是:作为 DevOps 服务提供商，我们如何在我们所做的事情中灌输某种程度的一致性，这种一致性不是特定于工程师的(即，只有一个人知道它应该如何工作)，并且仍然会在企业级别上扩展？

从人的角度来看，我们使用团队，无论是人在同一地点还是虚拟地使用跨越广泛地理位置的工具的同一主干。从流程的角度来看，我们使用治理和教育来确保不同类型的技术在基础层面上采用相同的流程和方法。最后，从工具的角度来看，我们使用模板或框架(或者选择您的同义词)，允许我们构建一个外壳，指导自动化构建从父到子保持一致。这三个基本要素的结合导致了可伸缩的一致性。但仅此而已吗？

## 我们错过了什么？

会不会有另一个我们忽略了的基本元素——即抽象？一个恰当的例子:考虑一个拖放界面和一个键入界面在完成一个给定任务时的效果。两者都希望达到相同的结果。有人可能会说键入文本的方法为完成任务提供了更多的灵活性和定制性。但是拖放方法提供了一种一致的、简单的方式来一遍又一遍地做类似的任务。客观地考察这两种方法，拖放方法提供了类型化方法无法提供的一致性。对于打字稿，你必须经常检查标点符号和没有变化(增加或删除)，以“知道”这是和上次一样的脚本。另一方面，拖放方法是“固定的”或基本上不可改变的；它可能会限制定制(通过设计)，但它擅长一致性。

拖放方法通过从使用它的用户那里有效地抽象出键入的或脚本化的代码来实现这种一致性。用户仅在期望(或需要)时选择使用它；其余的机制是从用户那里抽象出来的。然而，拖放方法存在的原因不仅仅是一致性；这是为了简单。苹果电脑似乎就是建立在这个想法上的。对于那些年龄足够大，还记得电脑上的 DOS 的人来说，这里的相似之处马上就变得清晰了。许多年前，DOS 是一种基于键入的命令行操作系统(OS ),完全能够操作 PC。但苹果的图形界面让同样的功能变得“直观”，并迫使个人电脑行业进入 Windows 以保持竞争力。当像 iOS 这样优雅的东西存在时，没有人会选择像 DOS 这样的命令行操作系统，或者 Windows(或者在这里选择你的图形毒药)。

图形操作系统从用户那里抽象出核心功能，并尽一切努力对相同的功能进行优雅直观的打包。用户“得到”一部 iPhone，这就占了它的销量。使用 iPhone 不需要正规的教育课程或很强的记忆力。用户实际上已经从创建这样一个操作系统所需的所有输入代码中抽象出来，数百万行这样的代码被打包成滑动、哔哔声和优雅的图形显示。请记住，这个操作系统的核心是将用户从可能存在的可变性中抽象出来，如果数百家公司创建自己的 iOS 版本。简单性与一致性相匹配，苹果的质量是一个结果(无论好坏)。但无论苹果的质量如何，它都比允许 iOS 供应商或其构建有很大程度的可变性要好得多。

## **在 DevOps 中扩展抽象** 

现在进入 DevOps。容器是在我们的学科中广泛流行的一种抽象层次，用于保持硬件细节远离典型的软件工程师。这种抽象的价值是众所周知的。我的挑战只是将这种想法扩展到下一层 DevOps 工具中。如果包含数据库 DevOps 自动化的能力只是每个构建工具都完全理解的拖放方法的产物，会怎么样？当然，您可能必须首先将这种想法的表达限制为 Oracle 或 SQL Server，以捕捉这一领域中产品和技术的细微差别和特定功能。但是，如果有人为 Oracle 构建一个“容器”，我敢打赌，选择使用 Oracle 将大大超过其竞争对手，至少在这些容器或抽象层与其他数据库产品一样有效之前是如此。

抽象现象不必局限于硬件，或者如我所提议的那样，局限于数据库平台。它也适用于。NET 或 Java 开发工作放在首位。当在. NET 商店或 java 商店工作时(或在此选择您的特定开发工具)，获得一个想法、对其进行编码并使其通过构建过程所需的步骤将在很大程度上是相似的。即使是栈顶——也就是说，应用程序本身的开发——也可能是从平凡的细节中抽象出来的可行的候选对象，因为它与构建结构或给定环境类别的部署相关。

为应用层创建有效的容器实际上限制了可变性，并增加了可预测性。我意识到它必须对技术类型敏感。的。网店有自己的容器。java 商店有他们的，等等。唯一的问题是，我们是否能够包含足够多的公共核心步骤，以生成具有给定技术类型的构建，从而形成价值的抽象构造。随着时间的推移，这将包括今天广泛使用的每一种技术。

通过抽象进行简化的努力最终将使我们能够随心所欲地包含诸如 WebSphere 之类的技术。它还将允许我们为使用相同抽象结构的新竞争对手更换 WebSphere，只需一次重建我们所有的应用程序。这种力量对开发团队很有吸引力。它促使应用程序开发人员和运营工程师开始合作，寻找能够执行给定规范的最经济高效的技术。在某件事情上做到最好不再是一个以后无法逃脱的牢笼。

以后将根据性能和拥有成本(即运营成本)来选择技术组件。如果我们在构建例程中使用的只是一个带有通用的、定义良好的参数的拖放式方法，那么切换就是非常简单的。客户能够通过简单或容易的方式将产品转换为同类最佳产品，这给供应商带来了压力，让他们真正成为同类最佳产品。如果性能受到影响或者新版本充满了错误，开发人员只需通过抽象(不是很长、很复杂的脚本，其中一切都必须正确，包括每月第三个星期二的满月和背景中的格里高利圣歌)将其切换出来。

## **对底线的冲击** 

在大型组织中，DevOps 工具的选择通常是一个棘手的问题。关于灵活性、可扩展性以及给定工具是否可以定制以适应我的开发团队的独特小雪花的争论接踵而至。也许这些争论正朝着错误的方向发展。也许我们不应该重视和评估给定工具提供的可扩展性或定制，而应该更仔细地研究可扩展性是如何实现的。

对于一个无意中选择进入脚本行业的企业来说，这实际上是在声明:“我将维护我用来构建构建的脚本，就像我维护这些脚本用来创建构建的代码一样严格。”因此，我们在没有意识到的情况下将我们的编程人员增加了一倍——一半从事应用程序代码，另一半从事脚本代码，在构建期间“自动化”交付构建。虽然整体速度可能会提高，但代价是本已昂贵的员工数量增加一倍。

作为替代，如果企业客户询问工具供应商他们的工具使用起来有多简单，他们的方法有多标准化。虽然我们可能不喜欢失去一定程度的灵活性，因为我们可能无法定制拖放方法构造，但业务的回报是企业级的使用简单性和可伸缩性。我不仅避免了人员增加一倍，实际上我还可以释放资源，专注于他们最喜欢的学科和领域，而不是执行脚本维护。抽象作为一个构造:从硬件层到应用层，它可能是一个驱动基础，让 DevOps 在未来许多年保持扩展并降低创新成本——但前提是你开始要求它。

要继续对话，请随时[联系我](/cdn-cgi/l/email-protection#d69da4bfa5a2bfb7b8f898b3baa5b9b896beb9a2bbb7bfbaf8b5b9bb)。