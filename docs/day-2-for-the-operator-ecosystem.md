# 运营商生态系统的第 2 天

> 原文：<https://devops.com/day-2-for-the-operator-ecosystem/>

Kubernetes 最初关注的是无状态应用，它不依赖于实例间的协调或客户端会话间的数据共享。在实践中，这通常意味着我们可以停止和启动我们的无状态应用程序，而不会丢失数据或影响客户端连接。

如果所有的应用程序都是无状态的，那么应用程序的部署和管理将会非常简单，但不幸的是，这并不是所有的用例。第二类应用程序是有状态的，应用程序在其整个生命周期中保留数据或状态。虽然 SQL 数据库等较老的单一应用程序适合这种模式，但也有许多架构，其中构成特定服务的各个元素实际上以某种方式聚集在一起。它们之间可能共享状态数据，或者它们需要一起同步。

Kubernetes 的一个基本特性是调度器可以在代理之间移动 pod，这对于无状态应用程序来说很好，但对于有状态应用程序来说就不太好了，因为有状态应用程序倾向于在运行期间保持其存储和网络不变，除非以非常特定的操作方式进行处理。为了尝试处理有状态应用程序的复杂性，Kubernetes 1.5 添加了 StatefulSets，这给了我们稳定网络和存储的概念。但这并不能解决我们所有的问题，因为 Kubernetes 仍然不知道豆荚里到底发生了什么。

典型地，这些类型的应用程序有一组生命周期状态，这些状态需要动作的逻辑顺序来维持操作。有状态应用程序倾向于在它们的元素之间进行协调，因此，一般来说，如果我们只是启动和停止实例，那么我们可能会影响应用程序的正确行为 — 我们可能需要等待数据的重新平衡，或者在升级操作中可能会涉及多个步骤。这也适用于您可能执行的许多操作，如缩放，并且这些操作也往往是应用程序特有的，因此 Cassandra 集群的管理方式不同于 Kafka 集群。Kubernetes 提供给我们的现成范例中没有关于如何管理这类应用程序的特定领域知识，那么我们如何自动化和打包这些知识呢？

解决这个问题的方法是 [算子模式](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) 。操作员将操作任务封装在代码中，因此我们可以使用 Kubernetes APIs 来编排应用程序生命周期操作。操作人员对特定领域的知识进行编码，这些知识涉及应用程序所需的生命周期操作 —h 如何扩展、如何升级、如何从故障场景中恢复等等。

当我们在集群中安装一个操作符时，我们将得到一个控制器，它是管理特定事物生命周期的代码，并且封装了特定领域的知识。我们还将获得一组自定义资源定义，它们扩展了 Kubernetes API 以处理新的资源类型，因此它们添加了一个新的类型，您可以将数据放入其中并进行实例化。

现在有许多不同的方法来构建操作符。第一个出现的是操作符框架，它起源于 CoreOS，但从那以后出现了一系列不同的构建操作符的方法，包括[kube builder](https://github.com/kubernetes-sigs/kubebuilder)、 [元控制器](https://github.com/GoogleCloudPlatform/metacontroller%5C) 和[KUDO](https://kudo.dev/)。这些都采用不同的方法来构建操作符，从 SDK 要求的围棋专业知识和深厚的 Kubernetes 知识到多态操作符的 KUDO 方法，可以通过使用 YAML 非常简单地进行配置。

对于管理大型集群的集群管理员来说，开发方法和管理界面的激增可能会带来问题。开发操作员来管理的应用程序类别几乎总是更大的应用程序堆栈的一部分，它们之间存在依赖关系。如果我们有许多以不同方式编写的操作符在我们的集群上运行，我们如何确保它们能够彼此互操作，以及我们如何验证和测试它们？

当我们依赖其他服务时，我们主要关心两件事:如何访问和使用它，以及它做什么。KUDO 项目正在致力于 Kubernetes 操作员界面(KOI)来解决这个问题，使操作员能够基于一组众所周知的 CRD 轻松地相互组合。这个接口也不仅仅是关于连接字符串和秘密；锦鲤旨在回答“这个操作者实际上是做什么的”这个问题。通过将操作员的行为导出为 CRD，可以编写诸如 CLI 和 GUI 之类的工具，更好地抽象用户需要执行的任务，而不必理解定制资源库。

定义行为是一回事，验证行为又是另一回事。我们如何编写标准化的测试来确认一个操作者确实做了它说要做的事情？为了尝试和解决这个问题，KUDO 项目还开发了一个测试框架，[【Kuttl】](https://github.com/kudobuilder/kuttl)，它允许运营商开发人员编写测试来证明正确的行为。Kuttl 在 KUDO 项目之外有更广泛的用例，能够测试各种 Kubernetes 资源的一致性，因此这是一个独立的项目。

这些围绕标准化、定义和测试的努力将使我们能够建立运营商的生态系统，这些运营商可以自然地相互组合，无论实现方式如何 — 允许用户构建他们可以确信将一致互操作的应用堆栈，而不是通过假设正确的配置值将一群不相关的运营商串在一起。协作和跨项目工作是运营商生态系统未来的关键，现在整个行业越来越多的协作努力都带着这些目标。

*要了解更多关于集装箱化基础设施和云原生技术的信息，请考虑来阿姆斯特丹的 [KubeCon + CloudNativeCon EU](https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/) 。CNCF 已决定推迟该活动(原定于 2020 年 3 月 30 日至 4 月 2 日)，改为在 2020 年 7 月或 8 月举行。*

![](img/275a3532f9a072da9d6f7ed3e9c630e5.png)

*本文由 D2iQ 云原生应用首席工程师 Gerred Dillon 合著。Gerred 在 Kubernetes 上为大规模工作负载构建工具。他是 Kubernetes 通用声明操作符的创建者，并协助 Kubebuilder 子项目、SIG API 机制和 CNCF SIG 应用交付。*

— [马特·贾维斯](https://devops.com/author/matt-jarvis/)