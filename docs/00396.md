# 基础设施自动化和 API 税

> 原文：<https://devops.com/infrastructure-automation-api-taxes/>

自动化是 DevOps 的关键组成部分之一，这一点在许多调查和研究中显而易见，这些调查和研究侧重于组织从跨运营团队实施该方法中获得的好处。自动化本身始于(或者应该始于)一个全面的 API。这意味着基础设施——以网络和应用为中心——需要通过 API 公开它所需的无数配置选项以及它提供的可选功能。

毕竟，正是通过这些 API，设备和系统之间以及跨操作组的集成才得以实现。大肆吹嘘的 SDN 或云“生态系统”实际上是预打包和验证集成的委婉说法。通过 API 进行的集成。

当然，这些相同的 API 可供每个人使用，并通过自动化将应用从开发转移到生产所需的各种[供应和配置](https://devops.com/blogs/provisioning-vs-configuration/)任务，为[操作化](http://www.slideshare.net/lmacvittie/operationalize-all-the-network-things)应用部署奠定基础。

API 允许细粒度的自动化和编排，每个旋钮、按钮和滑块选项都可以翻转、切换或转动。形象地说，可能的特性和功能越多，可以操作的按钮、旋钮和滑块就越多。

每一个这样做的调用都需要小心管理。异常时有发生，错误时有发生，任何脚本或工具都应该仔细验证这些调用中的每一个都是成功的。这需要大量的代码。代码本身会引入错误的可能性，需要[维护和审查](https://devops.com/blogs/dark-side-infrastructure-code/)以及所有好的开发实践。也会影响执行时间的代码。鉴于大多数 API 都是 RESTful 的，并且需要通过标准的 HTTP 交换进行调用，因此每个 API 调用都需要发送时间、执行时间和接收响应时间。开销基本上是 API 税；对于您调用的每一个 API 调用，您都在付出时间的代价…而且是更多的时间。

Martin Fowler 在他的文章“[微服务和分布式对象的第一定律](http://martinfowler.com/articles/distributed-objects-microservices.html)”中提到了这一点:

> 这种差异的结果是你对 API 的指导方针是不同的。过程调用可以是细粒度的，如果您想要 100 个产品价格和可用性，您可以愉快地对您的产品价格函数进行 100 次调用，另外对可用性进行 100 次调用。但是如果该函数是一个远程调用，通常最好将所有这些都打包到一个调用中，一次性询问所有 100 个价格和可用性。

因此，对于足够复杂的系统，需要另一种选择:模板。模板并不取代 API，而是提供了一种额外的、更加紧凑的方法来自动完成相同的任务，但是没有高粒度 API 调用集所带来的开销。模板封装了一个配置；将各种旋钮、按钮和滑块的设置编入单个配置工件中。在细粒度的基于 API 的集成中，这些设置中的每一个都必须在自动化脚本或系统的外部进行维护。每个 API 调用将包括一个(或者可能两个)这些变量，这些变量是从维护特定于应用程序的数据集的某个文件或系统中读取的。这引入了许多潜在的故障点。无论是文件还是数据库，变量必须在与 API 调用相关联之前被检索，然后被传输到接收设备。错误可能发生在读取、格式化或传输上。

相反，如果所有的变量都作为一个单一的、经过验证的配置模板工件存在，那么它就可以作为一个单一的实体，通过一个 API 调用被发送到相关的设备或服务。潜在故障点的数量被有效地减少到读取/检索和传输。这极大地简化了过程，并减少了实际执行目标设备或服务的配置所需的时间。

除了通过将供应和配置任务从潜在的数百个 API 调用减少到一小组调用来简化集成之外，这还具有作为代码策略更容易适应基础架构的优势，其中常见配置被视为工件并像其应用程序对应物一样存储在存储库中。

有一个转折点，在这个转折点上，使用基于模板的方法优于单个 API 调用。这一点发生在驱动基于 API 的自动化的脚本变得像应用程序一样复杂之前，因此带来了相关的问题，如错误率、故障排除时间和可维护性。

基于模板的方法简化了上游工作负载和集成以及离散自动化脚本，将所需的变量集减少到几个，通常是那些依赖于网络特定值的变量，如 IP 地址和网络分段成员(代表 VLAN、VXLAN、NVGRE 等的标签或 id)。

这进一步确保了应用部署的一致性(进而提高了底层基础设施的稳定性)。

API 是个好东西。他们是 SDDC、云和 SDN 等软件定义的架构的关键推动者。但是支持 API 的基础设施并不一定意味着仅仅基于复选框和单选按钮。这可能是有价值的，但它也可能导致集成工作与手动工作一样复杂(甚至更复杂)。基于模板或策略(应用驱动)的方法与用于交付和执行此类构造的 API 相结合，可以提供一种更加干净、更加一致和稳定的方式，将配置流程集成到更大的软件定义架构中。