# 将 ARA 集成到传统 RM 中

> 原文：<https://devops.com/application-release-automation-next-step-rm/>

应用程序发布自动化(ARA)是一个术语，从单一的、以应用程序为中心的角度来看，它包括几个 DevOps 构造。本质上，ARA 意味着单个应用从构建到部署的自动化(即使部署是为了生产)。当然，自动化术语中包含或暗示的是构建自动化或构造；部署自动化，可能包括供应；以及治理自动化，包括测试和批准。

如果您公司的应用程序组合很小，或者如果应用程序彼此完全独立，使用 ARA 来描述您的 DevOps 连续体或多或少是一种完全的术语。然而，如果您的应用程序组合包含相互依赖；您需要一个协调的/预定的发布事件，将多个应用程序以特定的顺序或时间投入生产；或者您需要满足超出单个应用范围的一揽子合规性治理要求；您将需要学习如何将基于 ARA 的 DevOps 策略与更传统的发布管理(RM)规程相集成。

## **澄清 ARA**

ARA 思维的一个更好的含义是，它把价值——或者强调价值——放在它应该在的地方；也就是在应用程序上。自动化基础设施是很好的，但是如果没有应用程序在其上运行，基础设施本质上只不过是未开发的容量。大多数首席信息官不喜欢闲置多余的计算能力。因此 ARA 的想法将自动化的焦点放在了它应该在的地方:将“应用程序”从构建转移到产品发布。

ARA 也是开发方法论中立的，这意味着构建、部署和发布自动化看起来是一样的，不管代码是使用敏捷还是瀑布来准备的。请注意，敏捷倾向于推动对更快交付系统的需求，但是一旦构建准备好开始，即使遗留的开发团队也可以在一致的交付系统自动化中找到价值。毕竟，正是一致性通过减少错误和创造可预测性来降低支持成本，从而提高质量。自动化中的一致性允许扩展，而自动化中的可变性阻止扩展。

ARA 还允许堆栈内的深度。如果代码位于栈顶，那么服务器的操作系统位于栈底(可能是酒窖中的网络和地窖中的设施管理)。ARA 在代码中引入了自动化相关技术层的概念，如数据库服务、中间件或消息服务，可能还包括虚拟机的供应，甚至在需要时配置操作系统。

然而，向下移动堆栈的实用性在于，变化的范围将继续比单个应用程序产生更广泛的影响。我通常不会为我创建的每个应用程序安装一个 Oracle 实例；更常见的情况是，我有几个应用程序依赖于我的 Oracle 设置的一个实例。因此，当我沿着堆栈向下移动时，我自动执行的实际更改更倾向于配置调整。更有可能的是，我的特定应用程序需要进行配置更改来适应它，而不是在我的应用程序下全新安装一个支持技术组件。同样值得注意的是，当你在堆栈中向下移动时，与应用程序代码相比，改变的频率要慢得多，并且改变的成本或影响会大大增加，因为你开始影响更多的东西。

## **解构阿拉** 

因此，ARA automation 包括所有传统的 DevOps 规程，但将它们限制在单个应用程序的角度，如下所示:

构建自动化:这包括版本控制每个特定的构建。它还包括打包所有的组件技术，以创建一个可部署的包，用于整个软件开发生命周期(SDLC)的部署。这里的黄金法则是在您的构建自动化中创建“一次构建，多次部署”的理念。对代码、包含的配置文件或堆栈中的相关技术组件的更改必须发生在 DEV 类环境中。一旦可部署的包在开发中令人满意地完成，它将在进入最终发布的生产环境之前，不加改变地通过任何其他层的测试环境。

**部署自动化:**由于每个可部署的包在构建过程中都受到严格的版本控制，因此现在可以在给定的 SDLC 环境中测试失败的情况下向前滚动(正常部署)或向后滚动(恢复到以前的版本)。一些常见的环境类别包括集成测试、性能测试、用户验收测试和生产前质量保证(QA)测试。智能开发运维部署工具能够只部署(或覆盖)与可部署包中列出的版本不同步的组件。这种智能部署功能减少了时间，并确保了与“应该”存在的一致性。

**供应自动化:**这是部署自动化的一个分支。对于那些使用虚拟机或云技术的人来说，部署自动化可以包括动态配置或设置任何类别的环境的能力。测试完成后，可以让相同的环境退役，以免浪费容量或预算。配置裸机服务器被人工交互排除在外，尽管一旦工程完成物理工作，应该在其上运行什么也可以完全自动化。

**治理自动化:**尽管大量的测试可以并且应该在开发中进行，但是在 SDLC 发展的后期，大量的测试必须在其他测试类环境中进行。因此，在构建和部署模板或脚本之外隔离测试自动化的能力是一个好主意，仍然使它可以从整个工作流管理器(通常包含在 DevOps 的发布编排或发布自动化工具中)调用或执行。这提供了运行一系列测试的灵活性，而不必重新构建应用程序或重新部署应用程序。除了测试评估之外，可能还有由组织内的治理团队或遵从实体驱动的其他过程规则。在最终推广到生产之前，必须满足并通过所有这些标志。

## **整合 ARA 和 RM**

依赖是简单的恶魔。彼此完全独立的应用程序可以利用 ARA 策略，并根据需要随时部署到生产环境中。其他人不会受此影响。但是，如果一个给定的应用程序在上游具有依赖性——我从其他人那里获取数据或与其进行交易——或者在下游——我的数据被提供给其他人——那么我的生产之路必须包括测试一个不同于我自己的应用程序。现在确定失败的责任在哪里需要政策，而不仅仅是常识。在两个相互依赖的应用程序同时发生变化的情况下，同步状态变化需要策略来管理，也需要更复杂的 SDLC 测试环境来管理。

当需要比单个应用程序更广泛的视角时，RM 的传统 DevOps 规程或其同义词 release orchestration (RO)成为解决方案。RM 允许根据需要对投入生产的应用程序进行排序。它允许在依赖蜘蛛网开始时进行测试。RM 允许将公司治理普遍应用于所有试图进入生产环境的应用程序，而不必在每个部署脚本或模板中一遍又一遍地构建它。RM 可以生成复杂的日志，旨在满足外部监管机构对法规遵从性历史记录自动化的要求。当必须从更广的角度看待生产部署，而不仅仅是一次部署一个应用程序或部署在一个小的产品组合中时，这些工具就变得非常有价值。

鉴于这一现实，将 ARA 与 RM 集成的关键是确保自动化是由规程独立构建的，并且可以根据需要由规程执行。ARA 包含或组合了四个规程:构建、部署、供应和治理。RM 使用 ARA 包并用其他应用程序对其进行扩展，以创建所需的序列，或者在需要时启动选择性的较小单元，如测试包，以满足基于依赖关系的某些外部应用程序更改条件。RM 可以根据需要有选择地执行 ARA 创建的自动化，以适应更大的目标，而 ARA 继续专注于保持自己的应用程序尽可能高效。

## **对底线的冲击** 

没有一个正确的答案。在 DevOps 连续体中只有你持有的观点。知道 ARA 和 RM 最终都依赖于传统的 DevOps 规程，这为你“如何”交付创新提供了灵活性。在我看来，ARA 只是自动化构建和部署的下一个发展。这是合乎逻辑的下一步。

然而，DevOps 中的其他学科可能会从将创新转移到生产所需的工作流的更广泛视角中受益。例如，流程中监控自动化的集成、按需配置容量、安全监督和配置管理数据库(CMDB)集成—更广泛地了解这些服务如何以及在何处与 DevOps 集成，可能会减少为每个应用程序创建它们所需的劳动力，重新发明轮子—或者担心轮子有一段时间没有正确更新。在其核心，DevOps 试图创建单一的自动化来执行任务，提高速度，降低风险和提高质量。

除了在一个更广阔的视野会更理想的环境中追求单一应用程序的战略之外，这没有直接的财务影响。计算这一错误的代价就像从天空中挑选六个乐透号码一样:很难知道会发生什么；在那种情况下，一个人所能做的就是希望。

要继续对话，请随时[联系我](/cdn-cgi/l/email-protection#c78cb5aeb4b3aea6a9e989a2abb4a8a987afa8b3aaa6aeabe9a4a8aa)。