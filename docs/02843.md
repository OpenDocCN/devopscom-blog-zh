# 软件交付:摆脱局部最优

> 原文:[https://devo PS . com/software-delivery-shaking-loose-of-a-local-optimum/](https://devops.com/software-delivery-shaking-loose-of-a-local-optimum/)

这是一篇关于软件交付的文章，这是介于将代码推向版本控制和在生产中使用它之间的神奇或繁重的领域。为什么软件交付很重要？因为软件很重要，因为软件开发者很重要。我不希望我的软件交付碍事；我希望它能让我成为一名更强的开发者。

从代码到产品的路径是至关重要的，因为它决定了我们反馈循环的长度，从而决定了我们改进的速度和最重要的[交付周期](https://dannorth.net/2013/07/05/are-we-nearly-there-yet/)。

我们当前的工具认为交付是通用的——它们控制，我们填补空白。他们让我们构建、测试、部署。但是这些词对于每个应用程序、每个团队和每个企业都有不同的含义。在代码的编写和运行之间，还有很多事情要做，或者可以继续做。经常有林挺，批准和协调。需要考虑数据、安全策略、业务团队结构和审计。还有其他一些步骤我们不用费心去做，因为没有它们的位置:更新库、修改代码以符合标准、对只涉及文档的更改采取不同的步骤。

还有什么是我们没有想到的，因为它不适合当前的工具集？我想从顶部考虑交付。这样做，我可以更好地理解我的工作。

我们已经看到了操作技术的重大转变:容器、[日志聚合](https://www.humio.com/)、[可观察性](https://www.honeycomb.io/)、[可编程基础设施](https://www.pulumi.com/)和 [Kubernetes](https://kubernetes.io/) 。在我看来，Kubernetes 的杀手锏是它的 API——它可以通过自动化来控制。它接受指令并发出事件。

在运营和交付方面，这里的潜力甚至比我们意识到的还要大。

现代操作选项已经达到了新的抽象和潜力水平。然而，交付方面的进展只是渐进式的。

我们的工具是非常可配置的，有插件和可脚本化的位，我们总是可以退回到运行无限长度的 shell 脚本。但是我们是否陷入了局部最优呢？我们的想法够大吗？

## 我们拥有的

今天流行的软件交付工具是填空。当你不知道自己在做什么的时候，这是一个很好的开始。当你的业务增长时，当你的交付不再千篇一律时，你会怎么做？我们来看两个例子。

Travis CI 是我的最爱，因为它很容易上手。它很乐意在其基础设施上免费构建任何公共 GitHub 库。如果我的存储库符合一些简单的配置文件，比如部署到 Heroku 的 Rails 应用程序，噗！你的知识库中有一些非常简单的 YAML:

![](../Images/bcee80af73ccac931a8a33432286b80b.png)

我喜欢那个 YAML。它是声明性的。它包含数据。它填补了特拉维斯提供的空白。但是真正衡量一个工具的标准是当你离开快乐之路的时候。在特拉维斯你可以做任何事情。只需调用一个 shell 脚本。这是我的一个. travis.yml 文件的一小部分:

![](../Images/37396019480e7704bcb7edd965d0e98a.png)

它有 shell 命令。if 条件的 Shell 语法。以及对 shell 脚本调用的无限灵活性。travis-build.bash 脚本恰好包含四个函数、八个条件和(如果我没有理解错的话)多达七个程序调用。

这是编程好吗？一旦你的 YAML 调用一个 shell，它就不是声明性的。势在必行。或者是混合。😕

这是编程，但我的 YAML 和 Bash 不具备软件的资格。Bash 是一种脚本语言。它被设计成将程序粘合在一起，而不是构造程序；它缺少带有封装的可组合模块。没有类型我也能活，但是在 Bash 中你甚至不用声明函数参数！而且充满了[陷阱](http://mywiki.wooledge.org/BashPitfalls)。用 Bash 做它擅长的事情:调用其他程序。作为我们在更高层次上缺乏的灵活性的后备，Bash 并不出色。

YAML 不是一种编程语言，尽管它支持变量 T1，也有 T2 陷阱 T3。直到 YAML 包含被执行的命令；然后它就变成了一个程序，与 Bash 相比，它的错误处理或清晰命名选项甚至更少。请将 YAML 用于数据，而不是代码。

编程和软件之间有一条鸿沟。我们有软件的标准:它有设计——领域驱动的设计，我们和专家一起工作过。它有自动化测试。它具有模块化。它使用库和抽象。我想用一种为这一切而设计的语言。

直接跳到詹金斯。这比 Travis 更广泛地用于更广泛的交付流。它可以在内部运行。有数百个可用的插件。如此多的空白需要填补！这么多选择！现在，有了管道代码。首先，您可以编写一段 Groovy 来定义哪些存储库和分支获得管道。这使得 Jenkins 对新的存储库和分支机构更加敏感。这是朝着响应新项目的方向迈出的一步。

构建 Jenkins 的人认识到交付需要由控制代码的人来控制。我们没有在 GUI (hello，TeamCity)中构建每个存储库，而是在每个存储库中放置一个 Jenkinsfile。那个文件是 Groovy 格式的。Groovy 是一种编程语言，背后有 JVM 的所有模块和库。除了，你不能在你的詹金斯档案里得到所有这些。当 Groovy 在 Jenkins 中运行*时，您会受到限制。如果您想要从一个存储库到另一个存储库的一致性，您可以在 Jenkins 中安装自定义共享库，并在每个 Jenkinsfile 中调用它们。推行变革具有挑战性；在共享库发生变化后，这些不同的 Jenkinsfiles 文件中的任何一个都可能中断。它相当脆弱，而且仍然有限。这是进步。*

作为编程，这是一个进步，但我仍然不会称之为软件。当我写一个应用程序时，我使用的不仅仅是一种编程语言；我在语言系统工作。一个语言系统包括依赖管理、框架、linters、构建系统、编辑器、社区和该语言中可用的整个库生态系统。围绕 JVM、Node 和。比如说. NET。你运行的 Groovy 可以参与 JVM 语言系统，但是在 Jenkins 内部运行的 Groovy 没有这个权限。Jenkinsfile DSL 仍然是填空。

## 我们需要什么

将交付视为软件邀请我们，开发团队成员，坐下来与本地专家讨论我们的部署环境、安全性和其他问题。它邀请我们进行一次对话:交付对于这个应用程序、这个团队、这个组织意味着什么？我们希望一致性和可变性在哪里？然后我们可以创建并编码一个模型——在我们的业务和环境的上下文中，软件交付的[域](http://dddcommunity.org/learning-ddd/what_is_ddd/)的模型。我们可以[头脑风暴事件](https://www.eventstorming.com/)，比如推送或新的存储库以及我们希望总是发生的事情。我们可以将[部分](https://martinfowler.com/bliki/BoundedContext.html)分为团队特定的、组织特定的和社区范围的(开源)。

而不是“如何运行构建？我们如何运行测试？”我们可以问，“代码推送之后需要发生什么？”我们可以仔细思考我们是如何工作的，我们的软件是如何工作的，我们的业务是如何利用它工作的。我们是自己交付的领域专家。

这是我希望自上而下交付软件的首要原因。通过将交付视为软件，我们严谨地思考我们作为软件开发人员的工作。我们越做越好。

我想要的不仅仅是代码交付。我想作为软件交付。由我的团队自上而下控制，拥有丰富的库生态系统，为社区中常见的部分提供框架和服务。我希望交付是事件驱动的，可测试的，并在需要做出决定时与我沟通。

自自动化部署出现之前，我们已经走过了漫长的道路。我们现有的持续集成/持续部署解决方案已经尽可能地为我们服务了。增量更好(填空)不会把我们带到软件交付的下一个层次，也不会帮助我们作为软件开发人员达到下一个层次。是时候突破这个局部最优了。

## 我们走吧

为此，我们撰写了[软件定义交付宣言](https://sdd-manifesto.org/)。说说你对宣言的看法:它们有某种天赋，某种影响，某种对更美好世界的强烈渴望。这就是我们在这里表达的意思。是的，这是一个更好的世界，只适合开发团队，只适合复杂组织中的开发团队。但是我们很重要！软件对世界有着巨大的影响，为了让软件变得更好，我们需要更好地交付它。让我们抛开我们所习惯的。接受我们的工作不是写代码，而是在生产中运行有用的软件。让我们通过在软件中建模来更好地交付。

如果你是其中一员，就加入这场运动吧。签署宣言。

— [杰西卡·可儿](https://devops.com/author/jessica-kerr/)