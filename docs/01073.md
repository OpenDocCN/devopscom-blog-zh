# 如果我们用 Git 换 DevOps 会怎么样？

> 原文:[https://devops.com/what-if-we-had-git-for-devops/](https://devops.com/what-if-we-had-git-for-devops/)

我以前很讨厌 [Git](https://git-scm.com/) 。与我以前的源代码控制系统(SVN、SourceForge 和软盘)相比，它晦涩难懂，难以理解。创建一组文件和文件夹，然后将它们作为一个单元进行快照，这很方便。这很容易理解，并提高了我的个人生产力。

但是，当我试图与其他开发人员合作时，那张快照造成了巨大的混乱。

一旦我克服了学习曲线，Git 彻底改变了我写代码的方式。频繁的集成使得小的改变更有意义。我可以很容易地回顾合作者变化的影响。更重要的是，在我开发他们的增量修复和改进时，我可以保留我的工作。开发——尤其是开源开发——是一项团队运动，需要在最基础的层面上促进协作的工具。

但这不仅仅是学习 Git 我还必须调整我构建项目和合作的方式。

在这种情况下，DevOps automation 一直缺少 Git 的等价物。我们需要可组合性！

## Git 模型可以在 DevOps 中工作吗？

在过去的几年中，我们一直在构建优秀的配置自动化工具(Chef、Puppet、Ansible 和 Saltstack ),现在又有一波新的云模板(AWS CloudFormation、OpenStack Heat、Terraform)加入了竞争。这些工具就像我最初的源代码控制系统一样:它们创建了一个垂直集成的配置堆栈，适用于特定的案例和平台。有很多方法可以将它们合并到新的堆栈中，但最终感觉就像创建了一个全新的堆栈。

为什么合并脚本会创建新的堆栈？其他组件的变化往往会互相破坏。

当您重用某人的脚本时，他们的更改会很快破坏您精心构建的自动化。你不是在合作，而是在分流他们的工作。感觉就像我们在软盘上运行自动化数据中心。当我们在一个模块中修复一些东西时，很难将其推回到社区中——我们没有在模块之间建立清晰的功能边界，以某种方式隔离更改，从而减少使用其他作者的脚本的风险，并使其更容易做出改进。

隔离变更并不意味着我们不破坏集成！它只是让上游合作变得更容易。

根据我们的经验，答案是考虑像 Git 这样的 ops 脚本:即使在一个更大的集合中，我们也需要使各个部分独立和可分解。我们如何将 Git 转化为 ops 术语？回购就像完整的系统——目录映射到组件，文件映射到角色。像 Git 一样，当我们对任何项目进行增量更改时，整个系统都会受到影响。然而，我们仍然可以将变更隔离到一行，这样我们就可以管理协作工作。当变更的影响是孤立的(像一个文本文件)时，这是可行的，当变更是一个紧密集成的单元(像一个图像文件)的一部分时，这是失败的。

我们已经有了 git 和 ops 脚本。这有什么不同？

我们建议采用一种更加可组合的方法。每个 ops 角色都应该被设计成一个功能性角色，具有清晰的输入和最小的副作用。为了实现这种隔离，我们一直在构建一个编排平台 Digital Rebar，将正确的输入输入到现有的 opts 脚本中。这允许模块内的协作，而没有意外的外部副作用。它还允许重用模块，因为更改被很好地隔离了。

当变更被包含、增加和管理时，整个系统对多个作者更加宽容。这样，我们可以构建更像 Git 的系统自动化。