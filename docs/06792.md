# 保护管道内的秘密

> 原文:[https://devo PS . com/securitying-secrets-in-the-pipeline/](https://devops.com/safeguarding-secrets-within-the-pipeline/)

***一个组织如何编写源代码来使用秘密而不直接引用它们并冒着它们被泄露给公众的风险？**T3】*

2020 年结束了充满无数代码泄露的十年，[一个话题](https://cycode.com/blogs/life-after-a-source-code-leak/) [我们经常谈论](https://cycode.com/blogs/the-bad-coding-habits-that-leave-your-source-code-exposed/)。事实上，就在最近，在[价值 20GB 的内部文件被泄露](https://www.zdnet.com/article/intel-investigating-breach-after-20gb-of-internal-documents-leak-online/)并上传到公共共享网站后，英特尔成为了最新的受害者。

英特尔发现自己是一个好公司，因为它加入了 2020 年受害者的长长名单，这些受害者的机密源代码被非自愿地公开。

即使不是大多数，这些受害者也有一个共同的致命缺陷:他们硬编码了[机密](https://github.blog/2013-01-25-secrets-in-the-code/)(登录、令牌等)。)，然后将他们的源代码发布到可信的云计算服务平台，如在线 Git 存储库。

然而，将责任完全归咎于平台是幼稚的。长期以来，一个可靠的经验法则是，你放在网上的任何东西——不管有没有门禁——总是存在一定程度的风险。记住这一点，在任何情况下，都不应该在源代码中包含秘密。窃取源代码的破坏性足够大；你王国的钥匙[不应该包含在](https://devops.com/applying-secrets-management-to-devops/)里。

当然，说起来容易做起来难。如何编写源代码来使用秘密而不直接引用它们？在这篇博客中，我们将向您展示如何利用持续集成和交付工具在构建/运行时将秘密注入到代码中，而不实际将它们包含在代码本身中，从而在代码和秘密之间放置一层面纱。

## 注入秘密

发布依赖于秘密的源代码而不实际将秘密*包含在*代码中的一种方法是在源代码中使用占位符，这些占位符在构建时被替换为所需的实际值。

微软合作伙伴技术策略师 Primoz Kocevar 在他的 [Medium post](https://medium.com/faun/how-to-provide-secrets-to-a-container-at-build-time-ff5267134bbd) 中详细介绍了这样一种方法。总的想法是，秘密变量被提供给 Docker 映像，这样就不会在源代码本身中发现秘密。

一个预先设置好的环境变量存储着这个秘密。该变量在 Docker 文件中定义，用于创建图像。在构建阶段，秘密通过 Docker 映像传递给源代码中指定的变量。完成后，就可以部署应用程序和映像了。

如果你碰巧在 Kubernetes 上运行你的图片，你也可以利用[它自己的安全存储秘密的特性](https://kubernetes.io/docs/concepts/configuration/secret/)。这个方法允许您使用一些额外的选项，比如在 Kubernetes pod 中使用 Kubernetes 环境变量或 [ConfigMap](https://kubernetes.io/docs/concepts/configuration/configmap/) 来存储秘密以便在构建时注入。

顺便说一下，这种秘密注射的方法绝不是 Docker 或 Kubernetes 所独有的。尽管我们在这里将它们作为具体的例子来强调，但是同样的方法可以通过您部署 pod 或容器所依赖的几乎任何类似的解决方案来使用。

通过在您选择的微服务平台中巧妙使用环境变量和配置文件来注入秘密当然是一个可行的选择，但我们不认为这是最佳选择。考虑这种方法需要每个秘密一个图像。如果一个开发环境有一个秘密，一个生产环境有另一个秘密，每个环境需要不同的映像，那么这会变得很麻烦。

## 利用您的 CI/CD 工具

首先，给外行人一个快速入门:持续集成(CI)和持续交付(CD)工具和实践是更大的软件供应链的基本部分。*连续*流程是那些使开发人员能够在不降低产品可靠性的情况下，轻松、频繁地发布代码变更的流程。

持续集成工具和实践为创建、测试和构建源代码建立了统一的流程，并在此过程中与任何所需的外部系统集成。连续交付包括随后的活动，将源代码交付到基础设施的流程化和自动化，特别是当涉及多个环境时。

许多 CI/CD 工具为保护敏感数据提供了自己的内置解决方案。您可以在存储秘密时利用这些特性，直到在构建过程中需要注入它们的时候。

例如，Jenkins 提供了自己的凭证存储和自己的自动加密的 [Secret](https://javadoc.jenkins.io/hudson/util/Secret.html) 字段类型。(提醒一句:仅此并不能防止用户意外地在控制台日志中打印出一个秘密。)

另一个 CI 工具 CircleCI，[提供了许多保护秘密的选项](https://circleci.com/blog/security-best-practices-for-ci-cd/)，比如秘密屏蔽以防止秘密出现在终端输出和上下文中，这将对某些变量的访问限制为仅特定的用户组。

当然，有多少工具可用，就有多少附加选项。

我们可以利用这些特性来增强我们之前的例子:存储在 CI/CD 工具中的秘密可以在部署期间注入到我们的 Docker *run* 命令(或您平台的等效命令)中。换句话说，您选择的 CI/CD 工具将秘密注入到映像中，而映像又将秘密注入到相应的源代码变量中。这种方法确保我们的秘密永远不会出现在实际的源代码中。

提醒一句:即使使用了这种方法，您的秘密仍然只和您用来保护它们的工具一样安全。我们在这篇文章前面链接的 Bleeping Computer 文章指出了配置薄弱的工具本身是如何构成威胁的:“漏洞是由开发人员和逆向工程师 Tillie Kottmann 从各种来源以及他们自己寻找提供源代码访问的*配置错误的 DevOps 工具收集的”(强调我们的)。*

重要的是要强调这样一个普遍规律:没有完美的安全性。考虑一下，如果对这些工具的访问没有足够的限制，那么在这些工具中加密您的秘密提供的保护很少。我们建议应用[最小特权原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)，谨慎地限制谁被授予对每个工具的用户访问级别。

## 部署后保护

现在我们已经构建并部署了我们的无秘密代码，下一步是什么？

如果我们就此打住，我们会忽略一个事实，任何访问我们容器的开发者都可以看到我们的秘密。使用微服务基础设施的缺点是，从编写第一行代码的那一刻到全部上线，所有移动部分之间都有可能出现安全漏洞，这很容易被忽视。

容器和 pod 需要相互通信以及与其他端点通信，因此攻击者可以利用这一点，通过破坏一个容器或 pod，然后横向移动到其他容器或 pod，使其中存储的任何秘密都可以被窃取。您的分布式基础设施越大，防止这种情况就越困难，因为这样做所需的安全策略不可避免地很复杂。

幸运的是，许多工具都提供了选项，如容器/容器和端点之间的内置网络/防火墙策略、对静态数据进行加密的选项或执行最小特权原则的机制，如通过受限安全组。

有些工具还允许你配置一个[密钥管理服务(KMS)提供商](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/)来加密你的秘密。KMS 提供商对存储在 etcd 中的数据采用信封加密方案。这种方法的额外好处是，解密密钥远程存储在 KMS 上，而不是存储在同一台主机上。

## 结论

无论您在开发过程中使用什么工具，秘密都必须存在于源代码之外，并且应该在代码通过开发过程中(安全地)注入到代码中。

无论秘密最终存在于何处，无论是在远程存储位置、容器或 pod 中，还是在 CI/CD 工具中，它们都必须被加密，决不能以明文形式存储。

最后，世界上所有的混淆和加密都无法保护秘密免受懒散的用户访问策略的影响。应该始终遵循最低特权原则，应该严格管理用户安全组，以控制谁有权访问负责保护您的机密的系统。

尽管如此，错误还是会发生，而且这里讨论的工具都不能完全保证没有开发人员会意外地将秘密硬编码到您的源代码中。正是考虑到这一点，我们建议通过自动监控您的源代码库来增加另一层安全性。