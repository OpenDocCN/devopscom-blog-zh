# 注意你的语言:行为驱动的发展

> 原文：<https://devops.com/watch-your-language-behavior-driven-development/>

在软件开发领域有两种基本的设计方法:自顶向下和自底向上。自下而上，目标是将功能组合在一起，以“构建”出想要的结果。自上而下，目标是将问题分解成越来越小的部分，直到你有可实现的部分。

两者都有长处，通过对比，两者都有弱点。在前敏捷时代，分析和设计阶段几乎普遍是自顶向下的。他们将业务需求转化为功能需求，然后分解这些需求，并将组成部分分配给开发人员。随着代码的实现，设计中的弱点将会暴露出来，反馈将会返回到功能需求的层次——或者，在非常糟糕的情况下，返回到业务需求——并且将会进行一次小的迭代来解决问题。

当敏捷出现时，这是一个太慢的过程。可以肯定的是，它过去(现在)仍然被使用，并且产生了一些世界上最好的软件，但是一个敏捷团队不能无所事事地等待一个漫长的分析过程。Kan-Ban 和类似的工具/过程被引入来解决这个问题，使得被设计的部分更小，从而在某种程度上加快了过程。但较小的碎片在某种程度上意味着自下而上，水变得有点浑浊。

测试驱动开发(TDD)旨在通过在实际代码之前编写预期结果的测试来确保编写的代码满足技术需求。这是敏捷开发中最有成果的事情之一。虽然它有缺陷——最重要的是人的因素——但它确实让人们在编写代码时投入更多的心思，让代码更加严谨。编写测试的行为使开发人员想办法解决满足测试的问题。但是这些需求的来源仍然需要来自某种形式的过程。

进入行为驱动开发(BDD)。这不是真正的发展，虽然名字很吸引人。它可能被更好地命名为 TDD 的行为设计，但是这有点拗口。

简而言之，这个想法是业务所有者和分析师根据给定角色的需求来说话，而开发人员根据功能或给定测试集的结果来说话。这就产生了一个导致误解的鸿沟。BDD 的目标是让每个人都说同一种语言。它试图将 TDD 的精神延伸到设计/分析栈上——用今天的说法是“向左移动”——这样，正在开发的测试是一个从验收测试向下延伸到单元测试的层次结构，每个人都在说同一种语言。

今天流行的语言是 [Gherkin](http://toolsqa.com/cucumber/gherkin/) ，一种简单的需求规格说明语言，用(相对)严格定义的句子编写需求和测试标准。我说“相对”是因为，从单元测试的角度来看，这种语言有点松散。但是从基于角色的规范来看，它锁定了选项，以使环境和测试用例变得清晰。

事实上，在考虑到[smart bear](https://smartbear.com/)最近收购 [HipTest](https://hiptest.com/) 的时候，我开始思考所有这些问题。SmartBear 在使其工具兼容 BDD 方面进行了投资，HipTest 在很大程度上是一个 BDD 平台。两者的结合应该会在 BDD 领域看到一些有趣的动向。我与 SmartBear 就此次收购进行了简短的交谈，看起来该公司确实正在融合两家公司的优势，因此在接下来的几个月里值得关注。

到目前为止，BDD 的好处在于，每个人都可以用通用术语谈论产品的某个元素，而开发人员可以“向下”思考满足需求所需的代码，而业务分析师(或所有者)可以“向上”思考，以确定如何推广这个很酷的新特性。

有工具可以为各种语言生成 TDD 测试类/用例——特别是 my stable、Python 和 Java。这也可能是朝着正确方向迈出的一大步。就在几天前，我与一位同行进行了一次轻松愉快的谈话，我说，“让我们在构建时就可以自动生成测试，这样 it 经理就不会纠结于决定哪些代码行值得/不值得维护测试代码，然后我们再谈。”工具和框架，如 [Cucumber](https://cucumber.io/) 和 [JBehave](http://jbehave.org/) 实际上朝着那个方向前进，尽管它们的方法不同。

我们目前没有在工作中的实验室测试应用程序( [Android](https://developer.android.com/) /web 客户端， [Spring](https://spring.io/) API 服务器)上使用 BDD，但是我们将不得不考虑把它作为我们可以试验的另一个 DevOps 工具和实践。工具就在那里，过程在自顶向下与功能性相结合的分析和设计的棘手部分之间架起了桥梁。

毕竟，最终目标是给用户他们需要的东西。如果 BDD 有助于使这个过程更顺利和更快，它就适合任何 DevOps 环境。

唐·麦克维蒂