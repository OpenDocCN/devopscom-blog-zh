# 代码不会说谎，其他操作咒语

> 原文:[https://devops.com/the-code-doesnt-lie-other-operations/](https://devops.com/the-code-doesnt-lie-other-operations/)

作为工程师，我们花很多时间讨论诸如发布流程、QA 环境和部署之类的事情。但是最终，大多数软件系统失败是因为软件本身有缺陷。代码不会说谎——您几乎总能在代码本身中找到问题的解决方案。当然，如果您在一个批次中部署了太多，从代码中寻找答案是一个非常耗时的过程。毕竟，有时最微小的错误也可能导致一整串代码脱轨，而且不得不在一大堆代码中寻找一根细小的针并不好玩。

“代码不会说谎”这句话有几个推论:

*   “像了解自己一样了解自己的数据。”有时，数据本身的质量会导致系统表现不同。
*   “特性是燕尾服上的一个 bug”，这主要是针对你的产品人员的。
*   "哪里有一个臭虫，哪里就有许多."当你发现一个问题并导致一系列系统性的问题时，起初看起来可能很糟糕，但事实是，你有机会在短时间内解决很多问题。

我有一个化学老师，他曾经说过，“鼹鼠就是鼹鼠，”指的是阿伏伽德罗常数。我的版本是:“bug 是 bug 是 bug。”行为不正确的特性(即使是按照规范构建的)是一个 bug。表现不佳的系统是一个缺陷。暂时的失败是一个错误。竞态条件是一个错误。不管它们长什么样，我们的工作就是消灭它们。

## 分支就绪是个笑话

关于分支/开发模型，一个非常有才华的工程主管曾经说过，“分支就绪是一个笑话”。当 23 个不同的团队准备将他们的分支集成到主干上时，代码变更在几乎没有测试/认证的情况下四处乱飞。我们甚至有无法编译的代码。

当所有 23 个分支都碰到主发布分支时，一切都乱套了。这是实际的功能、集成和性能测试开始的地方。这个模型的关键问题是集成和认证发生在游戏的后期。另一个问题是，我们没有遵守我们自己的标准，即什么构成分支机构准备就绪；相反，我们不断放宽限制，直到坏代码进入系统。

我们转向了基于主干的开发模型，在这种模型中，直接对主干进行检入，所有代码都必须经过编译和预先测试。持续的集成和测试整天整夜地在主干上运行。我们可以随时从后备箱装船。

现在你可能会问自己，这和运营有什么关系？答案是:一切。我们可以控制对站点的更改。我们可以证明站点发生了什么变化。我们每时每刻都得到保证，到达站点的变更具有最低的质量。这些较小的变化使我们能够更频繁地将比特移动到网站上。我们不会被迫进行大规模的整体部署，这必然会给站点本身带来更大的风险，而且通常没有回滚的能力。

## 从“分支就绪是个笑话”中学习

代码不会说谎并不意味着你总能理解它的所有含义。关键是将任何单个版本中被更改的代码量限制在工程师或自动化系统能够理解的范围内。通过避免包含成千上万个变更的大型、单一版本，而是单独测试、验证和考虑每个变更，我们可以理解代码告诉我们什么。我们可以放心地将我们构建和部署的东西发布到主干。

## 一字之变

我们生活在一个由比特和字节组成的世界里(每字节八比特)。一个字节相当于一个字符。在某些情况下，一个字符的变化是良性的。例如，将信息页面上站点的成员数量从 134M 更改为 135M (4 到 5)不会对站点造成任何损害。

但有时，一个字符的改变可能是灾难性的。考虑一个对 www.yourcompany.com 有一个字符错误的 DNS 更改。做错了就停播。理解一个变化出错的影响是非常重要的。如果它会造成很大的影响，那么我们需要确保我们理解了变化，并有一个清晰的计划来在必要时回滚它。

这里有一个很好的例子，说明一个很小的变化会非常快地偏离方向:我们曾经安排了一次维护，以测试通过一个欧洲接入点的路由流量。不幸的是，在 DNS 条目上，生存时间参数被设置为一个很大的数字(小时而不是分钟)。结果是，这种改变一旦实施，几个小时内都无法完全恢复。这是一个一字之差的改变。

## 从一字之变中学习

代码不会说谎，但只有当我们注意的时候，这才是最重要的。简单来说，不是所有的变化都是均等的。通过花时间去思考一个改变的目的是什么，以及它可能出错的各种方式，我们总会比不做尽职调查要好。一个字符的变化可能是良性的，也可能是灾难性的。在继续之前，重要的是要弄清楚任何变化可能带来的后果(不管它们看起来有多小)。

当出现问题时，运营部门往往是下班后第一个接到电话的部门。因此，我们对运送到我们站点的代码质量有既得利益。通过在代码投入生产之前努力提高代码质量，您可以显著减少遇到的问题数量。

从代码提交到源代码控制的地方开始。对于每一个变更，问一些简单的问题:代码还能编译吗？您的应用程序还能正确构建吗？它还能正常工作吗？通过为每个变更自动询问这些问题，我们获得了基于任何提交部署新版本应用程序的能力。

一旦我们将良好的代码质量纳入源代码控制，我们就可以开始通过使用[金丝雀进程](https://www.linkedin.com/pulse/mttd-mttr-key-benjamin-purgason)进行进一步的改进，并开始关注诸如性能之类的事情。记住，代码不会说谎。如果我们能够理解每一个变化，那么我们就可以在问题发生之前就开始预防。

这篇文章是“运营中的每一天都是星期一”系列文章的一部分在本系列中，我们将讨论我们面临的挑战，分享我们的战争故事，并回顾我们作为运营领导者所学到的知识。你可以在这里 *阅读简介并找到其余系列* [*的链接。*](https://www.linkedin.com/pulse/introduction-every-day-monday-operations-benjamin-purgason)

## 关于作者/大卫·亨克

David Henke 拥有超过 35 年的技术工作经验，包括在 LinkedIn、Yahoo！，以及 AltaVista 公司。他还是两家不同软件公司的创始人，这两家公司都被收购了。目前，David 在 NerdWallet 和加州大学圣巴巴拉分校等机构担任各种董事会和顾问职位。