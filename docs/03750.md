# 我们现在(可能)都是负载测试人员

> 原文:[https://devops.com/were-all-load-testers-now-maybe/](https://devops.com/were-all-load-testers-now-maybe/)

根据 VersionOne 的一项调查，超过 94%的组织已经有了敏捷或开发运维计划，或者计划在不久的将来采用它们。作为采用这些更加迭代和快速的软件交付方法所需的过程转换的一部分，组织正在重新评估*所有与软件开发和测试相关的*实践，包括负载测试。

传统上，负载测试被推迟到瀑布发布周期的后期。专业的性能测试人员应用遗留的负载测试工具在发布之前验证应用程序的性能。为什么这已经不够了？

1.  随着团队转向更加组件化的应用程序(包括云原生应用程序、微服务等)。)，一个应用程序涉及许多高度分布式的组件，其中任何一个组件的性能问题都会对整个应用程序产生连锁反应。
2.  现在新功能每周、每天或每小时发布一次，每个团队都需要即时了解他们的增量变化是否会对性能产生负面影响。
3.  越晚开始负载测试，暴露、调试和解决性能问题就越困难、耗时和昂贵。

由性能测试专家进行的深入负载测试仍然至关重要，但它不能提供对敏捷和开发运维至关重要的快速按需负载测试水平。开发人员和测试人员需要一种方法，在新功能通过交付管道之前暴露关键的性能问题。为了实现这一点，开发测试团队成员必须能够轻松地:

1.  创建负载测试，为他们开发的功能提供快速反馈；和
2.  根据需要执行和扩展这些负载测试，而无需花费传统上建立、配置和维护性能测试实验室所需的高昂成本和精力。

# 传统的负载测试并不适合所有人

然而，负载测试长期以来一直是性能测试专家的领域，原因是:它很难。今天的开发人员和测试人员没有时间(或愿望)去处理所有的技术细节，这些技术细节是让负载测试正确工作并使脆弱的负载测试与快速发展的应用程序保持同步所必需的。

处理负载测试脚本的传统方法是在协议级别(例如，HTTP)。这包括使用 JMeter 和 Gatling 等开源工具以及 LoadRunner 等遗留工具进行负载测试。虽然在协议级别模拟负载具有能够从单个资源生成大量并发负载的优势，但是这种能力是有代价的。学习曲线很陡，复杂性很容易被低估。

造成这种复杂性的罪魁祸首是 JavaScript。在 2011 年，通常每页不到 100 KB 的 JavaScript，这刺激了大约 50 个或更少的 HTTP 请求。现在，这翻了一番:我们看到平均每页 200 KB 的 JavaScript，这给了我们每页 100 多个请求。

仅仅在一个简单的搜索页面上运行搜索就涉及到诸如在页面加载后异步处理 XML HTTP 请求之类的事情。您还会发现动态解析和 JavaScript 的执行，浏览器缓存中植入了静态资产和对内容交付网络的调用。

![](../Images/278de40d764b63186ba82e919f5fb07c.png)

对于更侧重于业务的示例，请考虑 SAP 费奥里演示应用程序。假设我们想要加载测试两个简单的动作:导航到一个页面，然后点击“我的收件箱”图标。这实际上在协议级生成了 120 多个 HTTP 请求。

![](../Images/66ffc4d1cc593e89f5377317e05ce7e1.png)

当您开始构建您的负载测试模拟模型时，这将很快转化成成千上万的协议级请求，您需要如实地记录这些请求，然后将它们处理成工作脚本。您必须检查请求和响应数据，执行一些清理并提取相关信息，以便在业务级别真实地模拟用户交互。不能只是像用户一样思考；你也必须像浏览器一样思考。

您需要考虑浏览器自动为您处理的所有其他功能，并弄清楚如何在您的负载测试脚本中对此进行补偿。会话处理、cookie 头管理、身份验证、缓存、动态脚本解析和执行、从响应中获取信息并在未来的请求中使用……如果您想要成功生成实际负载，所有这些都需要由您的工作负载模型和脚本来处理。基本上，你负责做任何需要的事情来填补技术和业务水平之间的差距。这既需要时间，也需要技术专业化。

你可能会想，“好吧，那我们就用‘记录和回放’工具。”理论上，你可以在你的浏览器和服务器之间放置一个代理，记录所有通过的流量，然后设置好。不幸的是，事情没那么简单。即使您在 UI 级别进行交互，测试仍然是基于协议级别的。假设我们正在查看与一个用户执行上述简单的“单击收件箱”操作相关联的流量。当我们在两个不同的时间为同一个用户记录同一个动作时，我们需要考虑请求负载中的几十个甚至几百个差异。

当然，你可以通过一些努力来解决这些差异。不幸的是，当应用程序再次改变时，您又回到了起点。您的应用程序更改得越频繁，这就变得越令人痛苦和沮丧。

# 采用基于浏览器的方法

总结一下这里的挑战:现代 web 应用程序越来越难以在协议级别进行模拟。这就提出了一个问题:为什么不从协议层转移到浏览器层——特别是如果用户通过浏览器的体验是你最终想要衡量和改善的？

当您在浏览器级别工作时，一个业务操作在浏览器中可能会转化为两个自动化命令，而在协议级别则需要几十个(如果不是几百个)请求。缓存、cookie 和认证/会话管理等浏览器级功能无需干预即可工作。有很多方法可以在浏览器级别模拟流量: [Selenium](http://www.seleniumhq.org/) 显然是最受欢迎的，但是也有很多[跨浏览器工具](https://en.wikipedia.org/wiki/List_of_web_testing_tools)——其中一些可以让你不用进入脚本就可以测试。

然而，从历史上看，以负载测试所需的规模运行这些工具是不可行的。在 2011 年，如果你想用 Selenium 启动 50，000 个浏览器，你需要 25，000 个服务器来提供基础设施。此外，提供必要的基础设施既昂贵又耗时。

今天，随着基于云的技术的显著可用性，基于浏览器的负载测试的概念是可行的。与此同时，谷歌 Chrome 和其他项目正在提供快速自动化和更好的内存配置文件，以及无头或无用户界面的浏览器变体。事实上，对 headless Chrome 的测试表明，有可能远远超过每台机器两到五个浏览器的行业标准基准，并实现每台机器大约 50 个浏览器。

突然间，生成 50，000 个浏览器的负载变得更加容易实现——特别是当云现在可以让您访问数千个负载生成器，这些生成器可以从任何 web 浏览器启动，并且可以在几分钟内启动并运行。不必等待昂贵的性能测试实验室获得批准和建立，您可以立即开始，每小时只需花费几美分。对绩效的快速反馈不再只是空想。

在 [Flood IO](https://flood.io/) ，我们在 Flood Chrome 中获得了浏览器级用户(BLU)的研发成果:这是一种基于浏览器的负载生成方法，基于谷歌的 API，用于实现无头 Chrome 自动化。这种方法降低了编写和维护测试的复杂性，同时保持了每台机器的并发性和性能。它在更高的抽象层次——用户层次——创建脚本，然后通过云分发这些测试，以实现更好的规模经济。

为什么要考虑这种新的负载测试方法？

1.  简单的脚本——或者根本没有脚本
2.  降低测试复杂性
3.  从用户角度一次性测试整个堆栈
4.  能够测试任何用户行为
5.  记录网络和用户交互时间以进行前端优化
6.  更容易更早更频繁地测试
7.  更易于维护
8.  比其他 Selenium 负载测试快 10 倍

或者，只用一句话:因为它是专门为 DevOps 构建的。

# 协议级负载测试仍然有时间和地点

当然，没有一种单一的负载测试方法能够始终解决每个人的负载测试需求。例如，如果你试图测试一个不能从浏览器访问的应用程序，BLU 的方法就不适合你。

此外，在某些情况下，您可能会忽略使用 JMeter、Gatling 或基于 API 的测试用例等工具进行协议级测试。例如，如果您想模拟 API 的负载，我仍然建议运行测试，直接在协议级别测试它们。

不过，最终重要的是要记住，协议级测试可能更容易维护，并相应地使用它们。如果您只需点击一下鼠标就能发出 20 个后台请求，那么您是愿意在协议层处理脚本编写的所有技术问题，还是愿意用一行 BLU 脚本来实现相同的业务功能？

# 最后的想法

通过降低传统上与负载测试相关的复杂性，BLU 负载测试为开发人员和测试人员提供了一种快速、可行的方法来获得关于代码更改如何影响性能的即时反馈。它旨在帮助非专业性能测试人员快速开始负载测试，并创建可以在 CI/CD 流程中连续运行的负载测试——只需最少的维护。有了这种新的“精益”负载测试方法，任何开发人员或测试人员都可以开始进行负载测试。

[添商贩](https://devops.com/author/tim-koopmans/)