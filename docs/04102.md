# 在部署中使用应用程序增量

> 原文:[https://devops.com/using-application-deltas-deployments/](https://devops.com/using-application-deltas-deployments/)

从 Unix 早期开始，开发人员就一直在对他们的源文件进行版本控制。还有人记得 SCCS 吗？在那些日子里，存储非常珍贵:磁盘很小，非常昂贵，而且存储源文件每个版本的完整副本效率太低。因此版本控制工具将简单地存储增量——文件从一个版本到另一个版本的变化。这更有效率；如果您只修改了一个 3000 行的文件中的一行，系统将简单地存储新的一行和一些关于它在文件中的位置以及谁做了修改的元数据。

有些工具会保存文件的最新版本，如果您想恢复到早期版本，可以使用反向增量来记录更改。这通常更有效，因为通常开发者想要文件的最新版本。因此，应用增量来获得更早的版本比从一个 3 年前的文件开始并通过 472 次更改来获得您想要的文件更有效。

如今，磁盘存储确实比 1981 年便宜了 300 万。(我手机里的存储在 1981 年就要 3800 万美元了！)正因为如此，存储增量不再是曾经的灵丹妙药。此外，CPU 现在可以比以前更快地处理数字，因此现在可以使用数学来压缩和存储新版本文件的完整副本。这就是 Git 等现代修订控制工具的作用。

这非常有趣，但是这篇文章的标题是“在部署中使用应用程序增量”那么，我为什么喋喋不休地谈论源代码版本化呢？

好吧，困难就在这里:虽然增量可能不再在跟踪源文件的变化中扮演太多的角色，但是当涉及到部署应用程序时，它们肯定会这样做，并且因为类似的原因困扰着我们(或者我们的父母！)30 年前。

## 应用程序由组件组成

坦率地说:在一台服务器上包含一个二进制文件的应用程序不需要增量。这类似于对单行源文件的更改。您需要做的就是用新的二进制文件替换旧的二进制文件，这样您就部署好了。但是应用程序变得越来越复杂:

*   应用程序可以跨多个服务器拆分。一个 n 层应用程序可能在不同的服务器(甚至不同的操作系统)上运行不同的层。
*   应用程序可以全部或部分容器化。您可以拥有多个容器，每个容器运行不同的微服务。
*   可能存在与应用程序更改相关联的数据库更改。事实上，应用程序的变化可能只包含数据库的变化。数据库更新几乎总是作为增量部署；alter 脚本用于添加和删除列、表和索引。

同样，一个二进制文件可以由许多不同的源文件(每个源文件都有自己的版本控制)构建，一个应用程序可以由许多不同的二进制文件*组件*组成。显然，如果应用程序由许多不同的组件组成，并且这些组件驻留在不同的服务器或容器上，那么每次部署新的应用程序版本时都部署每个组件将是浪费、耗时且容易出错的。

因此，应用程序版本“增量”将跟踪在被部署的应用程序版本和目标环境上的组件版本之间哪些组件已经改变。这允许部署工具只部署已经改变的组件。那么，我们需要跟踪什么来实现这个工作呢？

*   **组件版本。**显然，我们需要对每个单独的组件进行版本控制，这样我们就知道哪个组件的哪个版本包含在任何特定的应用程序版本中。
*   目标环境中的任何特定端点上存在哪个组件版本。这样，如果我们将要部署的应用程序拥有组件的版本 5(比如说一个 DLL 或一个 WAR 文件),并且版本 5 已经存在于目标环境中，那么我们就不部署那个特定的组件。

这种方法有许多优点。您可以部署到现有环境中，并且只部署已更改的组件，从而最大限度地减少停机时间并降低故障风险。您可以部署到新配置的环境中，并部署应用程序中的所有组件。然后，如果您需要启动一个新的虚拟机(或容器)，部署会推送一切。但是下一次部署到该环境时，只部署已经更改的组件。

## 数据库增量

当涉及到数据库组件时，我们可能需要考虑特殊情况。还记得我们提到过，数据库更改几乎总是以增量形式交付，即 SQL“alter”脚本对数据库模式的先前版本进行更改。好吧，如果你所做的只是部署应用程序的下一个版本，那么这很好。但是，如果您部署的版本比环境中的版本领先几个版本，该怎么办呢？如果测试和生产环境将部署“拉入”到他们的环境中(而不是通过连续的交付过程将它们“推入”)，这很容易发生。现在，仅仅应用与该应用程序版本相关联的 alter 脚本在任何不包含该应用程序的先前版本的环境中都不起作用。

想象一个版本为 6 的应用程序(“我的应用程序”)。它有两个组件:一个 WAR 文件和一个数据库组件，后者包含向前滚动数据库模式的 alter 脚本。这是最后四个版本的样子:

![](../Images/2c6b38d6589ac150d33c26fffcb82bde.png)

所以版本 3 有了新版本的 WAR 文件；version 4 有一个新版本的 WAR 文件和一个数据库修改脚本，可以向表中添加一列。版本 5 只改变了数据库(它修改了使用这个新列的存储过程)。版本 6 对 WAR 文件进行了新的修改。

现在，在一个连续的交付过程中，作为目标的测试装备将接收每个新版本。因此，当部署版本 4 时，rig 将接收版本 4 的 WAR 文件，并执行 alter 脚本将列添加到表中。然后，当部署版本 5 时，将只运行 DB alter 脚本(alter.sql2)修改存储过程。WAR 文件没有部署，因为服务器已经包含 WAR 文件的版本 4。当部署版本 6 时，只部署 WAR 文件的版本 5。这正是我们想要的。

但是现在当我们转向用户验收测试(UAT)时会发生什么呢？到目前为止，我们已经完成了尽可能多的自动化测试；在 UAT，真正的用户需要登录我们的测试系统，以确保他们对一切都满意。所以我们不打算做“推”在 UAT，当他们准备好接受新版本的应用程序进行测试时，测试主管会进行“拉动”。因此，他们将“我的应用程序版本 6”引入他们的测试环境，并让他们的测试人员排队喝咖啡、吃披萨。

但是如果测试环境当前是版本 3，会发生什么呢？对于 WAR 文件，没有问题——WAR 文件的组件版本有所不同，因此部署了新版本。但是数据库会发生什么呢？没有与应用程序版本 6 相关联的 alter 脚本，但是没有应用 alter.sql。1 和 alter.sql2，数据库模式对使用 myapp.war 无效；5.测试将会失败，与其说是“在第一个障碍摔倒”，不如说是“在围场摔倒”

增量使我们能够解决这个问题。我们需要做的是识别代表数据库变更的组件，并让它们按顺序应用于每个临时版本。这样，在部署所需的应用程序版本之前，应用连续的数据库“增量”将数据库前滚到正确的模式版本。

因此，在我们的例子中，从版本 3 到版本 6 将部署以下组件:

![](../Images/99f98014f26eb943ca67dfcf624307ef.png)

所以我们将部署(并运行)alter.sql1 添加新列，然后 alter.sql2 修改存储过程，最后部署 myapp.war5.增量意味着我们做了使应用程序版本达到期望状态所需的最少工作。

## 结论

对组成应用程序的组件进行版本控制意味着很容易确定一个应用程序版本和另一个版本之间的差异(变化)。记录目标环境中端点上的组件版本有助于只部署已更改的组件，从而最大限度地减少停机时间，并使部署更快、更少出错。识别数据库的增量使我们能够向前滚动数据库并在版本之间跳转，这在从敏捷的“推”向以瀑布为中心的“拉”部署模型过渡时是非常宝贵的。

菲尔·吉布斯