# DevOps 辩论:图像驱动还是构建驱动的交付

> 原文:[https://devo PS . com/devo PS-debates-image-driven-delivery-vs-build-driven-delivery/](https://devops.com/devops-debates-image-driven-delivery-vs-build-driven-delivery/)

在过去的 12 个月里，Docker 和容器化范例已经挑战了一些软件交付原则的基础。人们正在求助于 18 个月前闻所未闻的东西，现在正在使用它们来更快更便宜地成功交付软件。其中之一就是围绕构建驱动交付和图像驱动交付的争论。

在过去的几十年里，软件被一个构建系统打包和构建，并标上一个数字；测试人员将他们的测试与作为被测试实体的标签对齐，并提升它们，直到它进入生产环境。对于任何人来说，内部版本号是交流交付管道中软件状态的最重要的标记之一。

一段时间以来——主要是由于 Docker——几个团队正在转向一种用映像定义软件版本的方法。应用程序和部署程序中的每次更改都会创建一个新的映像，该映像将被标记并用作软件版本，以供下游使用并最终投入生产。

接下来的争论是，哪种选择更好？

让我对此进行尝试，并邀请您对此进行思考。

## 对于构建驱动的交付:

1.  构建有助于标记软件，而不考虑目标硬件和其他部署选项。它捆绑了所有的依赖项，以确保软件按照预期部署时能够正常工作。这为开发团队提供了一个很好的交接点，可以转移到下一组工作，或者说 sprint。
2.  构建的规模要小得多，因为构建只捆绑了应用程序所需的必要软件；因此，让它们与每次更改保持一致并不是一个昂贵的存储主张。
3.  工件的版本控制和在运行时的捆绑使得 maven 等工具可以动态地构建和链接，从云中收集所有的依赖关系。这使得保持一个精简的构建更加容易，并且进一步减少了每个构建中要保留的冗余数据。
4.  这些年来，构建库已经成熟，提供了一种非常简单的方法来版本化和标记依赖关系，因此部署工具可以找到新版本并根据需要自动升级环境。

## 对于图像驱动的交付:

1.  映像将构建概念提升到了一个新的层次，并确保完全消除目标硬件和部署选项的可变性。它将应用程序捆绑在构建中，或者作为映像创建的一部分构建，并将映像作为构建推送。
2.  Docker 注册中心已经开始通过为最终用户提供类似的选项，将自己与构建库进行比较。
3.  映像驱动的选项提供了一个更好的好处，即标准化您的所有环境，消除了“它在我的环境中工作；在你的吗？”如果它可以在开发人员笔记本电脑的容器中工作，那么它也应该可以在生产中工作——除了资源的大小和数量之外，一切都是一样的。
4.  映像比构建大得多，因为现在必须在映像中包含系统软件和应用程序基础软件。这个选项以前闻所未闻，但是随着容器图像下降到兆字节，这在今天不是一个大问题。通过分层，当你开始剥离依赖关系的洋葱时，大小可以进一步减少。看看 Brian 关于这个话题的文章。

我想选择取决于您的应用程序处于其生命周期的哪个阶段，团队真正应该问的问题是:

a)我们是否需要改变太多才能选择一个增量收益的选项？

b)我是否有环境差异的问题？

c)我能否将这些选项合并，以获得一个混合解决方案？

但对我来说，更大的问题是，如果你明天从零开始，你会选择哪个选项？我很想听听你的想法。

最后，不管你倾向于哪种方式，形象驱动的解决方案是将 DevOps 文化带入团队的最佳方式之一:如果形象起作用，团队就赢了；不管是操作代码还是开发代码！