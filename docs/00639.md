# 木偶:最佳实践

> 原文:[https://devops.com/puppet-best-practices/](https://devops.com/puppet-best-practices/)

这是包含自动化、供应和配置管理的多部分系列的第 4 部分。本文将介绍 Puppet 的最佳实践。

Puppet 是最受欢迎的配置管理工具之一，有时也会变得复杂。在这篇文章中，我将简要介绍一些实践，这些实践已经成为好的、值得推荐的和高层次的最佳实践。我想与世界分享其中的一些，以便初学者有一个先进的开始。

**1)。尽可能使用模块:**

木偶模块是每个人都应该使用的。如果您有一个正在管理的应用程序，为它添加一个模块，这样您就可以保存清单、插件(如果有的话)、源文件和模板。

**2)。将您的木偶内容保持在版本控制中:**

没有理由在开发 puppet 清单/模块时不使用版本控制系统。你可以选择你最喜欢的系统——最受欢迎的选择是 Git、Mercurial 或 Bazaar，它们被证明是特别有用的，因为它们提供了管理多个代码分支的便利。

版本控制得到了 Puppet 生态系统的良好支持。可以使用成熟的软件开发生命周期来管理 Puppet 清单的开发和维护，与真正实现“基础设施即代码”理想的基于分支的工作流紧密集成

使用版本控制有助于打开 puppet 的许多额外的可能性，比如更好地跟踪变更，在隔离的环境中测试您的 Puppet 清单，从一个环境到另一个环境提升您的配置，等等。版本控制甚至为您的配置代码提供免费备份。

通过使用像 Github 或 Bitbucket 这样的协作工具，你和你的团队可以很容易地在应用之前分别修改每一个变更。这导致了更好、更可持续的傀儡代码。将所有的 Puppet 文件置于版本控制之下被认为是最好的 Puppet 实践之一，无论何时您准备将任何类型的更改“部署”到 Puppetmaster，您只需将服务器上的工作副本与版本控制存储库中的代码同步。

**3)。利用环境:**

环境是傀儡代理节点的孤立组。傀儡主服务器可以为每个环境提供完全不同的主清单和模块路径。Puppet 的环境概念有助于首先在不太重要的服务器上应用您的配置更改，并且在这些更改已经过测试并准备好之后，再将这些更改推广到生产中。这使您可以针对不同的节点群体使用相同模块的不同版本，这对于在生产机器上实现 Puppet 代码之前测试它们的更改非常有用。

**登台**和**生产**是两个傀儡环境，登台环境用于向所有预生产机器初始配置服务器，生产服务器利用生产环境。两个环境都绑定到 Git 存储库中的特定分支，即 Git 中的 ***【主】*** 分支是 ***【生产】******【暂存】*** 分支是 ***暂存。*T19】**

**4)。使用预演:**

即使采取了最好的预防措施，有时你的傀儡清单并不完全符合你的预期。每当您实际运行 Puppet 代理来在您的服务器上应用您的配置更新时，事情有时会变得混乱。例如，如果它将更新配置文件并重新启动生产服务，这可能会导致计划外停机。此外，有时在服务器上手动更改配置会被 Puppet 覆盖。

为了降低出现问题的风险，您可以使用以下选项在*模式(也称为 noop 模式，用于无操作)下使用 Puppet 的代理:*

***傀儡代理[…]–详细–无操作–测试***

*通过利用这一实践，您将能够看到所有文件的差异，这些文件将根据您的期望进行修改和验证。这将有助于傀儡代理人只显示它会做什么，而不是它做了什么。*

***5)。用 librarian-puppet 管理 Puppet 模块:***

*处理模块依赖关系有时会成为一个令人担忧的问题，尤其是当许多人都在处理 Puppet 代码，并且每个人都要求在自己的计算机上测试它的时候。Librarian-puppet 是您的 puppet 基础设施的捆绑器，它通过自动管理您的模块依赖关系来帮助提供过程的健全性。*

*Librarian-puppet 根据你的“Puppetfile”管理你的模块/目录。当你运行这个工具时，它会自动安装、更新或删除模块，总是与 Puppetfile 中指定的相匹配。您的 Puppetfile 成为您需要什么模块、什么版本、标签或分支的权威来源。*

*一旦使用了 Librarian-puppet，你就不应该修改模块目录的内容。各个模块的 repos 应该被更新，用一个新的发行版和版本标记在你的 Puppetfile 中。这将有助于解决和安装模块的依赖性，并了解兼容性问题。*

*Librarian-puppet 通过一个简单的命令自动从 forge 和 git 仓库中引入模块，简化了 puppet 基础设施的部署，从而使您不必手动安装和管理模块。部署通常包括以下两个简单的步骤:*

*   *将您的主要源代码与您的代码库同步(例如:git pull)*
*   *运行 librarian-puppet 来同步您安装的 puppet 模块*

****不使用任何版本说明符*** 的 Git 依赖*

***6)。保护敏感数据安全:***

*如今，数据安全性是任何组织的主要关注点。有些数据总是需要保持安全。例如，为了维护数据安全，可能需要在密码、私钥、SSL 证书等中加入您的傀儡代码。*

*不要把傀儡代码放在版本控制中，除非你完全意识到这样做的风险。T3】*

*如果您已经对 Hiera(一个木偶工具)有所了解，您就会知道为什么将数据从木偶清单中分离出来是一个好主意。不过，如果您不熟悉的话，使用 Hiera 租约您可以编写和使用可重用的清单和模块。在 Hiera 中存储了特定于组织的数据之后，Puppet 类可以从 Hiera 数据存储中请求它们需要的数据。*

*Hiera 允许您在 YAML 或 JSON 文件中存储有关服务器和基础设施的数据。从使用情况来看，你会发现 Hiera 文件中的大多数数据本质上都不是机密的…所以我们应该仅仅因为一些不安全的元素就避免对 Hiera 文件使用版本控制吗？**当然不是！！！！！！！！！！！！***

*诀窍是使用 Hiera 的能力来组合多个数据源或后端*

***或***

*你可以做的是将 Hieradata 文件分成两种类型: **YAML 文件**用于你的*“主”* Hieradata 文件和 **JSON 文件**用于存储你的*“安全”*数据。这些 JSON 文件不受版本控制，安全地存储在一个位置，即**“puppet master”**。这样，很少有人能真正看到敏感文件的内容。*

***7)。为你的高级类产生抽象:***

*将模块的所有使用打包到一个覆盖中，或者说打包到一个包装类中，及时提供了 Puppet 代码的更高的可维护性。例如，假设您想使用现有的 Nginx 模块设置一个反向代理服务器。不要直接在节点上分配“nginx”类并设置所有需要的东西，而是创建一个新的类，比如说“proxy_server ”,并使用您希望作为类参数的代理服务器的属性。在您的节点上分配“proxy_server”类不仅更好地陈述了您的意图，而且还创建了一个关于您所认为的“代理服务器”的不错的小抽象。稍后，如果你决定放弃 Nginx ( *极不可能)*或者使用另一个 Nginx 模块(*可能性更大！*)，那么您可能只需要更改“proxy_server”类的内容，而不是一堆混乱的节点定义。*

***最后:***

*Puppet 不是唯一可用的配置管理(CM)工具，但它是最成熟的，拥有一个由活跃的模块开发人员组成的大型社区。实施这些实践将有助于您从木偶中获得最大收益。*