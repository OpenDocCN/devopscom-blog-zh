# 在 DevOps 的世界里 ALM 死了吗？

> 原文：<https://devops.com/is-alm-dead-in-the-world-of-devops/>

DevOps 是否扼杀了应用生命周期管理(ALM)？如果这个问题让你头晕，你可能并不孤单；毕竟，就在几年前，ALM 还是一个新鲜的、新的想法——也是大多数敏捷实现的关键组成部分。那么 ALM 发生了什么，DevOps 为什么要杀它(如果这是实际发生的话)？首先，简单回顾一下历史:

在有 ALM(至少作为一个正式的概念)之前，有 PLM——产品生命周期管理。PLM 是 20 世纪 80 年代在汽车行业发展起来的，作为在整个生命周期中管理制造产品的一套集成实践。PLM 集成了需求和配置管理、计算机辅助设计和工程、资源规划、产品支持以及产品生命周期的所有其他关键要素。要做到这一点，不仅需要部门和项目管理层的集成，还需要产品相关数据库以及管理、设计和行政软件的集成。

在许多方面，ALM 是 PLM 原则在软件开发和运营中的应用。回想起来，这是一个不可避免的发展；PLM 本身的采用在很大程度上是由使其成为可能的软件工具的可用性和使用所驱动的。软件开发人员很快就开始将相同类型的工具和实践应用到他们自己的行业中。

与制造业的情况一样，在集成生命周期管理的想法流行之前，许多实际的管理工具就已经存在并在使用了。对于一个公司来说，在需求、设计、源代码管理、发布、测试、错误报告和整体项目管理等方面，使用单独的、非集成的工具和特定实践的组合是很常见的。这些工具中的许多都非常自然地融入了集成的理念——配置、构建和发布管理、需求和设计、测试、问题管理和用户支持——并且在许多方面，ALM 充当了将现有难题的各个部分组合在一起的理论和实践框架。

当 ALM 作为传统的瀑布式软件开发方法的一部分被实现时，它倾向于呈现方法本身的特征。这并不奇怪——集成使现有的实践更加有效，但它不一定改变它们，ALM 至少与相对不灵活的、自上而下的管理风格兼容。

但是 ALM 也适合敏捷框架。敏捷 ALM 工具与敏捷的快速、小团队、设计、编码和测试迭代配合得很好，并且整个 ALM 哲学本身很容易从传统的公司管理世界向下扩展到更直接的敏捷开发世界。最重要的是，ALM 的全生命周期集成的概念与作为敏捷基础的紧密的开发生命周期集成相吻合。在相当大的程度上，应用生命周期管理作为一种理念被嵌入到敏捷中，而真正敏捷的 ALM 的实现在很大程度上是寻找或开发正确的工具，以及将 ALM 实践扩展到敏捷的问题。如果没有与 ALM 高度集成的方法，敏捷就不是敏捷。

当然，DevOps 本身是敏捷的自然产物，它将运营引入到一个相对较小的团队的快速、频繁迭代开发的敏捷模型中。如果说有什么不同的话，DevOps 通过将集成从开发扩展到运营，提高了集成的水平，这意味着它实际上比基本敏捷更紧密地匹配了 ALM 的全部范围。毕竟，在应用程序的生命周期中，操作可能比开发占据更多的时间。开发运维是整个应用生命周期的第一线项目，因此开发运维管理从定义上来说就是应用生命周期管理。

在许多方面，DevOps 是在敏捷框架内实现 ALM 的最终结果。但是从传统管理的角度来看，结果看起来一点也不像 ALM，导致一些人怀疑在 DevOps 世界中是否还有 ALM 的空间。如果 DevOps 是应用于敏捷的 ALM 的实现，为什么看起来不是那样呢？到底是什么会让人怀疑 DevOps 是否杀了 ALM？

在传统软件开发领域中实现的 ALM 并没有挑战现有的将应用程序生命周期划分为离散阶段的方法——它只是将它们集成到一个项目和数据管理的整体系统中。然而，敏捷 ALM 模糊了这些阶段之间的区别，并且在很大程度上，DevOps 完全消除了它们。在不同的软件开发/支持阶段之间没有任何明确的区别，乍一看很难看出 ALM 如何映射到 DevOps 世界。

这是 DevOps 系统持续交付的自然结果；试图将 DevOps 周期分解成与传统软件开发阶段相匹配的离散阶段是没有意义的，因为它由小的、紧密相连的步骤组成，不注意传统的阶段边界。然而，传统的 ALM 仅仅是基于离散的软件开发阶段，因为它是在那些阶段是规则的环境中成长起来的。如果它是在敏捷/DevOps 世界中开发的，它就不会基于连续的、瀑布式的阶段。但是话说回来，在一个敏捷/开发运维的世界里，没有必要制定一个单独的应用生命周期管理的概念，因为它内置于开发运维之中。

所以 ALM 在 DevOps 的世界里还远未消亡，ALM 工具在 DevOps 中有着重要的地位。当然，这些工具的性质——或者至少它们的焦点——有些不同。在 DevOps 中，文化是 ALM 中缺少的一个关键元素，集成甚至更重要，管理工具需要将来自各种离散应用程序的数据整合在一起并加以理解。DevOps 取代了传统 ALM 的“开始并完成一个阶段，然后开始并完成下一个阶段”的范式，它更接近于“在这里、这里和这里进入流，并在不停止它的情况下监视和控制流。”过程和工具可能看起来很不一样，但是基本目的是一样的——管理应用程序的生命周期。