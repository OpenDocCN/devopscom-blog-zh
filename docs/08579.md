# 微服务的采用和软件供应链

> 原文:[https://devo PS . com/microservice-adoption-and-the-software-supply-chain/](https://devops.com/microservices-adoption-and-the-software-supply-chain/)

软件开发正在经历工业化，越来越多的软件由组件快速组装而成，并强调围绕软件验证和发布过程构建自动化。

现代的云原生软件不再是生活在单一存储库中的单一应用程序，其大部分依赖项都是独立的。它由厂商、云提供商提供的第三方组件和[开源软件](https://devops.com/?s=open+source+software) (OSS)组件整合而成，多达 90%的代码来自于这样的依赖关系。这使得开发人员可以更快地构建应用程序，但也使得维护变得更加困难，因为维护不再完全由他们控制。如果第三方供应商对他们的 API 进行了更改，开发人员就必须在应用程序崩溃之前对其进行更新。T3】

每个微服务都与数百个其他微服务交互，并且每个微服务都是独立构建和发布的，这使得很难理解如何协调它们之间的 API 更改。例如，如果您要对微服务进行 API 更改，这会对组织中的消费者产生什么影响？谁需要协调变革？当它都在同一个存储库中并且一次发布的时候，做出这样的改变就容易多了。

## **技术债务性质的变化**

我们继续称之为技术债务的，实际上是当第三方组件正在发展或具有公共漏洞和暴露(CVE)并需要升级时，与维护和升级我们的软件相关的活动。

这些都是单调乏味的重复性任务，通常由最有经验的工程师来完成，因为他们需要专业技术才能正确完成。这样的活动会使工程组织瘫痪，对工程师来说是一个巨大的负担；这往往会导致精疲力竭。高达 30%的工程时间花费在技术债务上。那种认为开发人员应该对积累的技术债务负责，并且正在做一些错误的事情来阻止他们继续下去的想法是非常令人沮丧和消极的。

然而，如果我们将技术债务重新定义为软件供应链管理，并停止将其归咎于工程，我们可以使维护更加可预测和一致。通过采取诸如清点第三方组件并确定它们在应用程序中的普及程度(框架比您仅从应用程序的一部分调用的第三方 API 需要更多的维护工作)，组织可以得出维护估计。

这些活动在组织中是高度重复的，因为每个人都在集成相同的第三方组件的子集，以创造业务价值。这种高度的可重复性让我们想到了自动化。

## **没有专门的软件维护开发工具**

开发人员写代码的时候，手往往落后于思想。他们思考的速度比他们输入代码的速度要快得多。你经常会听到开发人员在完成一项繁琐的任务后抱怨，“我的手指疼。”当他们的 IDE 可以自动完成语法时，它有助于将这种延迟减少到几分钟。

当一个主要的框架版本发布时，开发人员会考虑代码库。也许他们需要把这种类型改成那种类型，重新排序一些方法参数或者改变依赖关系。他们需要进行的变更类型是可列举的，并且必须几乎立即进行；同样，实施这些措施的能力远远落后于他们对问题的认识。通常，在处理大型代码库时，这种类型的延迟可能代表几个月或几年的工作。积累足够多的这种延迟，代码库可能会陷入停顿。

这种滞后扼杀了大多数高级开发人员的开发乐趣，并导致精疲力竭。升级/迁移将这种滞后放大了几个数量级。

然而，很少有(如果有的话)工具专注于帮助开发人员自动化这些补救/升级/迁移。IDE 的重点是帮助开发人员编写新代码和维护他们自己的代码，这是正确的，但是代码维护需要跨代码库的多个位置进行协调，在同一个存储库内或跨存储库边界。通常，开发人员在他们的存储库中有一个他们想要改变的模式，但是 IDE 仅仅建议这是对他们当前位置(一个文件)的改进。其他时候，如果开发人员想要更改 API 和他们的消费者，更改需要跨存储库边界进行协调。这就是为什么这项技术需要存在于 ide 之外的原因。

## **打开重写**

OpenRewrite 是一个开源项目，它将代码的语义分析和重构作为独立的操作来提供，这样每个人都可以随时使用和贡献；组合越来越多的重构操作，使得整个框架的迁移成为可能。它与构建工具集成，可以插入到不同的工作流中，从 CI 集成到多个微服务/存储库的大规模重构。与 IDE 或其他开发工具类似，OpenRewrite 操作代码的抽象语法树(AST)表示，但这个 AST 具有特殊的特征，允许它转换这个 AST 并生成代码回到标准文本表示。T3】

OpenRewrite AST 是通过引导编译器通过编译的前两个阶段来生成编译器类型属性 AST 而产生的。然后映射到 OpenRewrite AST，保留 AST 中的格式和中断循环。OpenRewrite AST 的三个独特特征是:

*   类型感知，允许 100%正确的语义代码分析和转换。
*   保持风格，所以产生的转换在它们所应用的项目中是惯用的。因此，应用于多个项目的相同转换可能会看起来不同。
*   Serializable，允许从构建中输出 AST，并在构建之外一起对其进行操作*。*

*OpenRewrite ASTs 充满了关于代码的元数据。将代码本身想象成一棵由各种顶点和边组成的高度连接的树，我们可以开始了解这种表示的密度。只有语法元素是蓝色的，类型属性是黄色的，格式信息是红色的。如果我们只是表示语法元素，树可能看起来像这样。*

*![](../Images/7dfe3d55b4c6c47a1143a136aa8183b5.png)T2】*

*添加类型属性和格式后，树看起来更密集了。*

*![](../Images/1c2ba10fe1210db94cee0deedc8a2dff.png)T2】*

*这个 AST 中涉及的数据的生成树可以在三维双曲空间中展开，然后投影到单位球面上，类似于二维空间可以投影到圆盘上的方式——著名的[庞加莱圆盘模型](https://mathworld.wolfram.com/PoincareHyperbolicDisk.html)。斯坦福大学的塔玛拉·芒兹纳首创了这种三维方法。*

*不属于生成树的每条边都被渲染成浅灰色，正如你所看到的，它是*密集的*！事实上，为了使这种布局更容易处理，我们在这个视图中省略了额外的 600，000 个表示类型信息的顶点，这使得语法本身看起来很小。*

*OpenRewrite 将单个代码搜索或转换操作称为配方。它提供了许多构建块配方，如查找方法、更改方法、查找传递依赖项、升级或排除依赖项。反过来，通过将这些配方组合成一个复合配方，可以将它们组合成更复杂的配方。当构建模块不够用时，可以用与我们想要转换的代码相同的语言编写一个程序，允许我们用开发人员已经熟悉的语言的全部表达能力来封装复杂的逻辑。我们不需要学习新的 DSL 或编程语言。*

*这些构建块抽象掉了许多细节，以确保我们对源代码所做的编辑符合项目的原始风格。这甚至对于复杂的变化也是可能的，例如从 Spring Boot 1 . x@ conditionalombean到 Spring Boot 2 . xanynestedconditionn 的自动迁移在它所插入的项目的上下文中看起来习惯上是一致的:*

*![](../Images/c930818e73ec9a4525f58f32add0b710.png)T2】*

*值得注意的是，OpenRewrite 不是 IDE 的替代品。随着软件现在由如此多的独立组件组成，我们需要开始使用超越单行代码的新方法来修复和管理它，以查看整个代码库。 T2】*

* * *

**[Moderne 的联合创始人奥尔加·昆兹奇](https://devops.com/author/olga-kundzich/)共同撰写了这篇文章。**