# 高保真 DevOps 的 5 个关键方面

> 原文：<https://devops.com/five-key-aspects-high-fidelity-devops/>

尽管我们谈论我们应该如何共享开发和运营的目标，但这远没有听起来那么简单。为了推动 DevOps 文化，我们还必须构建健壮的工具。这意味着预先投资五个关键领域:抽象、可组合性、自动化、编排和等幂。总之，这些概念允许在管道的每一级共享工作。不幸的是，人们很容易在一个层次上优化工作，而忽略真正的系统瓶颈。

为开发人员创造生产般的保真度是必不可少的:我们需要它来实现规模、安全性和升级。这不仅仅是分享努力；这是关于同理心和协作。

但是，即使 DevOps 作为一种文化运动被越来越多的人接受，我相信部署差异是一个尚未解决的大问题。当开发人员的工作环境与操作人员大相径庭时，就会产生“保真度差距”,使得团队很难合作。

在我们讨论成本和解决方案之前，让我先分享一个故事，当我还是一个目光敏锐的 OpenStack 爱好者时:

我在波士顿参加了第四届 OpenStack 峰会。我在戴尔的团队创建了开放式部署自动化 Crowbar，它可以在大约 30 分钟内转动原始服务器并安装一个完全正常工作的 OpenStack 群集。我不想夸大其词；有许多粗糙的边缘和先决条件。然而，自动化起了作用，OpenStack 就像一棵葛藤幼苗一样出现了。事实上，我们带了半个机架的服务器到峰会现场进行生产演示。

在我返回演示台的路上，我正和该项目的创始人之一一起乘电梯。他对自己创建的名为“Devstack”的新项目充满热情，并想展示一下他们设计的很酷的 logo。他滔滔不绝地说:“太棒了！它在我的笔记本电脑上的一个 python 环境中运行 OpenStack 的所有功能！你甚至不再需要 vagger 了——对开发人员来说，让 OpenStack 运行起来是一件超级快速和容易的事情，因为所有的配置都在 Python 中。”我看着他输入命令，文本滚动，欢迎我使用 OpenStack API。“看，现在我在运行 OpenStack！”

当时，这似乎是一个无害的玩具，因为单节点云部署对用户、测试人员和操作员来说是无用的。我指出，我们现在已经让我们的多节点自动化在虚拟机(VM)中工作，因此即使没有专用硬件也很容易使用。他问我们用什么写的。“主要是 Chef 和一些 Rails UI，”我回答道，心想我们已经做出了一些坚实的 2011 DevOps 选择。他不太热心，因为我们没有使用开发人员喜欢的 Python。即便如此，我还是鼓励他来试玩，但没有任何期待。

我们在 OpenStack synergy 的友好浪潮中离开了电梯。他跑进开发者休息室，我拖着沉重的脚步回到用户和供应商展示区。即使没有文字来描述它，我看到这个项目已经开始在开发商和运营商之间产生分歧。开发人员协作推动了对在单台笔记本电脑上运行的快速设置的需求。更重要的是，Devstack 去除了所有杂乱的多节点网络和 DevOps 工具，这些工具使得配置和运行 OpenStack 变得困难。在后来被证明是单向的旅程中，现在有了一个通用的开发人员环境。

不幸的是，开发环境配置并没有转化为产品。

事实上，OpenStack 部署是出了名的具有挑战性，并且有太多不同的方法。尽管付出了如此多的努力，但很少有人能够管理基本的运营里程碑，如升级和高可用性配置。我相信一个巨大的忠诚差距是这个故事的一个关键部分，虽然很悲伤。

我们不必带着忠诚的差距生活！

事实上，DevOps 的存在就是为了通过将开发者和运营商带到一个共享的空间来缩小这些差距。您已经非常了解将开发视为自动化管道以保持其可重复的必要性。

如果我们知道挑战，为什么我们允许这些差距？这是因为保真在复杂性、系统开销和时间方面的成本太高。我们尝试迭代的速度越快，这些成本就越大。这在组织的敏捷性和忠诚度之间产生了冲突；可悲的是，很少有团队愿意用保真度来增加开发人员的负担，或者用变更频率来增加操作人员的负担。

### 我们如何使富达在初始成本和持续成本方面具有成本效益？

有五个组件需要考虑:抽象、可组合性、自动化、编排和等幂性/可重复性。

**平台抽象**

平台抽象隐藏了环境和工具之间的差异，这些差异使得开发人员和生产环境不同。对于真正的保真，我们在非常广泛的意义上使用“平台”。云 API 或服务器是一个平台，操作系统或容器系统也是一个平台。在实践中，有许多可能的和可接受的抽象层。

团队需要投资于允许相同的自动化以相同的方式在多个平台上工作的方式。这需要修改自动化以适应不同的环境，并接受配置而不是做出假设。无论如何，这些变化是有益的，并且使您的自动化更加健壮和可移植。

添加抽象的最简单方法是外部化环境配置。由于操作系统很难检测更广泛的系统配置，我们需要将这些信息注入到您的部署中。不幸的是，这导致了“大规模预部署库存文件”反模式和我们的下一个组件。

**可组合性**

可组合性不仅仅是使自动化模块化。这意味着我们可以通过安装的各个部分传递信息，即±la功能编程。

在一个好的可组合设计中，每个单元都有定义的输入、输出、前提条件和行为。这使得我们可以将它们连接在一起完成工作。我们的系统应该能够将早期模块的输出连接到后期模块的输入。这消除了“预先配置文件的厄运”，因为我们可以建立系统知识的工作已经完成。由于这些函数是众所周知的，我们可以确定我们是否已经完成了所有需要的设置。

替代甚至比拥有链式配置流更重要。由于模块是孤立的动作和已知的参数，我们可以根据用户或基础设施驱动的需求创建替代模块。比如选择 CentOS vs. Ubuntu 改变包管理；然而，下游应用程序只关心它们的包是否被安装。我们需要在不破坏下游组件的情况下，让基于情境感知的模块检测和调整变得可以接受。

这种类型的变化容忍度对保真度至关重要。

**自动化**

你可能认为这是显而易见的；然而，我们在日常工作中都有忽略手动步骤或设置的倾向。常见的陈述，如“构建我的开发环境需要一天时间”，或者“我们总是在系统启动时运行这个预配置脚本”，表明我们并不像我们想承认的那样自动化。

当团队有不同的过程时，保真度差距就出现了。

我们不期望开发者使用数百台物理服务器；然而，我们可以期望他们以类似于操作的方式隔离组件。这增加了他们需要自动化的工作的开销。我们不期望运营商每天重置和重新部署系统 10 次；然而，我们可以期望他们使用不需要人工干预的可重复配置。

记住:在所有情况下，不需要*也不需要*相同的自动化！可组合性允许我们拥有相同状态的等价但不同的路径。

**序列/编排**

可组合性有一个缺点。如果您已经用健壮的可组合模块替换了脆弱的单片自动化，那么您将不得不增加一些复杂性来将它们链接在一起。这是不可避免的权衡，因为复合系统需要胶水来粘合。这种粘合剂就是编排。

事实上，添加编排并没有坏处。这是规模的需要。任何多系统配置过程都需要持续的流程编排。规模应用程序的本质是，我们必须在部署、扩展和升级期间横向协调整个系统的活动。这允许我们在节点之间创建信任关系，在尝试使用网络之前设置网络，并在升级 API 时协调服务器和客户端。等待循环和迭代收敛很难排除故障，也更难预测。

当您将组合和编排结合起来时，有一个具体的好处:小的工作单元创建了一个在操作上非常透明和并行的系统。这些是规模化运营的关键价值。

**等幂/可重复性**

最后一个部分是最难理解的:等幂。目标是允许我们的自动化系统中的模块多次运行，以使系统保持一致的状态。这允许我们重复执行一个组件，而不会损害或撤销我们已经完成的工作。

这个概念不是简单地跳过我们认为已经完成的工作！如果我们重新运行一个动作，那么这个动作每次都应该以请求的状态退出。如果状态已经很好了，那就什么都不做。如果未配置状态，则创建它。如果状态不好，那就修。基本上，我们希望每次都能自信地实现我们的最终目标，但从不做不必要的改变。

这不是一个简单的任务！配置的本质是改变系统，我们通常假设我们正在从未配置或错误配置到正确配置。对于幂等脚本，我们必须防止从正确配置到崩溃。

对于通常从干净的系统开始的开发人员来说，这似乎是一项繁重的工作，但是对于操作人员来说，当一个计时错误导致一个单元出现故障时，这是救命的。

### 嘿，你给我的部署增加了很多工作！

遵循这五个原则确实会增加一些开销；然而，无论如何，所有的改变都是有益的。它们使您的自动化更加健壮和可移植。更重要的是，它们减少了开发、测试和运营过程之间的摩擦。

部署保真是帮助推动成功的真正优势。希望这五项原则能使它成为一个更具体、更容易实现的目标。