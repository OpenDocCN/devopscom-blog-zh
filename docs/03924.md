# 低风险整体到微服务的发展，第 1 部分

> 原文:[https://devo PS . com/low-risk-monolith-microservice-evolution-part-1/](https://devops.com/low-risk-monolith-microservice-evolution-part-1/)

在设计和组织为期两天的微服务研讨会时，我一直在思考如何解释 monolith 应用程序分解，以及向微服务的过渡会是什么样子。这是材料的一小部分，但我想分享它以获得反馈(在研讨会中，我们会更详细地讨论你是否应该打破你的独石)。这是基于我自己的真实经验，以及过去几年我在北美与许多 Red Hat 客户的合作。第一部分探讨了架构，而第二部分(即将发布)将涵盖一些在这方面有很大帮助的技术。

在我们深入研究之前，让我们建立一些假设:

*   微服务架构并不总是合适的(将详细讨论)
*   如果我们发现我们应该去微服务架构，我们必须决定发生了什么与整体
*   在极少数情况下，我们会想把整块石头的一部分拆成原样；在大多数其他情况下，我们会想要构建新的特性或者重新实现现有的业务流程(以一种扼杀的方式)
*   在我们需要分解功能或重新实现的情况下，我们不能忽视这样一个事实，即 monolith 目前正在生产中，可能会带来大量的商业价值
*   我们需要一种方法来解决这个问题，并且对系统的整体商业价值影响很小
*   因为整体就是整体，所以很难/几乎不可能对它下面的数据模型/数据库进行修改
*   我们采取的方法应该降低演进的风险，并且可能需要多次部署和发布来实现这一切

## **提取微服务**

如果你深入研究这个主题的会议/博客帖子，你会发现它经常提供以下建议:

*   围绕名词组织
*   做好一件事又一件事
*   单一责任原则
*   这很难

恐怕这个建议没什么用。

更有用的资料讨论了一种有时看起来像这样的方法:

*   识别模块(现有的或者要编写的新模块)
*   将对应于这些模块的表拆分出来，并用服务进行包装
*   更新曾经直接依赖数据库表来调用这个新服务的代码
*   冲洗并重复

让我们仔细看看:

## **第一步:识别模块**

![](../Images/0937303c299ccf3d0de3919a0caed308.png)

你从一些肮脏的巨石开始。在上面的图片中，我已经简化了这一点，以表示这里可能涉及的不同模块和数据库表。我们确定哪些模块是我们希望从整体中分离出来的，并找出涉及到哪些表，然后从那里开始。当然，现实是独石与彼此合并的模块(如果有模块的话)更加纠缠在一起。稍后会有更多的介绍。

## **步骤 2:分解数据库表，包装服务，更新依赖关系**

![](../Images/231e7f04a0a2d6db7700bf241033ff72.png)

下一步是确定 Foo 模块使用哪些表，并将其分解到自己的服务中。这个服务现在是唯一可以访问这些 Foo 表的东西。不再共享桌子！这是好事。任何曾经引用 Foo 的东西现在都必须通过新创建的服务的 API。在上面的图像中，我们更新了酒吧和奶酪服务，现在每当它需要 Foo 的东西时就引用 Foo 服务。

## **第三步:冲洗并重复**

![](../Images/abc9026fc58080e66bfdc1ab836c1bc4.png)

最后一步是重复这一努力，直到你没有剩下更多的巨石。在上图中，我们对 Bar 服务做了同样的事情，您可以看到我们正在转向一种架构，在这种架构中，服务拥有自己的数据并公开 API，这听起来类似于我们所听到的微服务。

虽然这种方法通常是一套不错的指导方针，**但它错过了很多我们在这条道路上真正需要的保真度**。例如，这种方法掩盖了这样一个事实，即我们不能停止从数据库中删除表。另外:

*   单体很少适合于漂亮整洁的模块化
*   表之间的关系可以高度规范化，并显示出实体之间的紧密耦合/完整性约束
*   我们可能无法完全理解 monolith 中的哪些代码使用了哪些表
*   仅仅因为我们已经将表提取到一个新的服务中，并不意味着现有的业务流程停止，所以我们可以迁移每个人来使用该服务
*   将会有一些丑陋的迁移步骤，它们不能被希望消除
*   可能会有一个收益递减点，在这个点上，把东西从整体中分离出来是没有意义的

–等等。等。

让我们看一个具体的例子，看看方法/模式会是什么样子，以及我们在进行过程中可能有的选择。

## **具体例子**

这个例子来自前面提到的研讨会。我将围绕服务的划分添加一些色彩，但围绕领域驱动的设计、耦合模型和物理/逻辑架构，我们将在研讨会上讨论更多详细的指导原则，现在我们将不再讨论这些内容。从表面上看，这种方法似乎是处理现有整体功能的分解，但同样适用于在整体周围添加新的功能；这可能是更有可能的情况，因为对整块巨石进行改动可能会有相当大的风险。

### **遇见巨石**

这就是我们将要探索的巨石。它基于来自[developers.redhat.com](http://developers.redhat.com/)的 [TicketMonster](https://developers.redhat.com/ticket-monster/) 教程。该教程探索了如何构建一个典型的 Java EE 应用程序，并最终成为一个很好的例子——它并不太复杂，但有足够的内容，我们可以用它来说明关键点。在这篇博文的第二部分，我们将更深入地探讨技术框架/平台。

从这张图片中，我们可以看出 Monolith 将所有模块/组件/UI 共同部署到一个单一的 Monolith 数据库中。每当我们需要做出改变时，我们需要部署所有的改变。假设应用程序已经使用了 10 年以上，并且很难更改(出于技术原因，也出于团队/组织结构的原因)。我们希望打破用户界面和关键服务，使企业能够更快地、相互独立地做出改变，以尝试交付新的客户和/或业务价值。

**注意事项**

*   Monolith(代码和数据库模式)很难改变。
*   变更需要完全的重新部署和团队之间的高度协调。
*   我们需要进行大量的测试来捕捉回归。
*   我们需要完全自动化的部署方式。

#### **提取 UI**

![](../Images/3b8789cd45ad8310bd20b8ccd0673dce.png)

在这一步，我们将把 UI 从 Monolith 中分离出来。实际上，在这个建筑中，我们并没有从整块巨石上移除任何东西。我们开始通过添加包含 UI 的新部署来降低风险。这个架构中的新 UI 组件应该非常接近(确切地说？)到 Monolith 中的同一个 UI，并回调 Monolith 的 REST API。当然，这意味着 monolith 有一个外部 UI 可以使用的合理的 API。我们可能会发现事实并非如此；通常，这种类型的 API 可能更像“内部”API，此时我们需要考虑独立 UI 组件和后端整体之间的一些集成，以及更易于消费的面向公众的 API 可能是什么样子。

我们可以将这个新的 UI 组件部署到我们的架构中，并使用我们的平台缓慢地将流量路由到它，同时仍然路由到旧的整体，这样我们就可以在不停机的情况下引入它。同样，在博文的第二部分，我们将更详细地探讨这个问题；然而，[黑暗发射/金丝雀释放/滚动释放](http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/)的概念在这里(以及后续步骤)都非常重要。

**注意事项**

*   不要为第一步修改整体；只需将 UI 复制/粘贴到单独的组件中。
*   我们需要在 UI 和 monolith 之间有一个合理的远程 API 情况可能并不总是这样。
*   安全表面增加。
*   我们需要一种方法，以可控的方式将流量路由/分流到新的 UI 和/或 monolith，以直接支持[黑暗启动/金丝雀/滚动发布](http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/) 。

#### **从 monolith 上放下 UI**

在上一步中，我们引入了一个用户界面，并慢慢地将流量转移到新的用户界面(它直接与 Monolith 通信)。在这一步中，我们做了一个类似的部署策略，除了现在我们慢慢地发布一个移除了 UI 的 monolith 的新部署。如果我们发现问题，我们可以释放流量并停止/回滚。一旦我们所有的流量都流向没有 UI 的 Monolith(从这里开始称为后端),我们就可以完全移除 Monolith 部署。通过分离出 UI，我们现在已经对我们的整体做了一个小的分解，并通过依赖黑暗发射/金丝雀/滚动释放来降低我们的风险。

**注意事项**

*   我们正在从 monolith 上移除 UI 组件。
*   这需要(希望)对 monolith 做最小的改动(取消/删除/禁用 UI)。
*   同样，我们使用受控的路由/整形方法在不停机的情况下引入这种变化。

#### **推出新服务**

![](../Images/e98864325fe5040c5917ce2863492cb7.png)

下一步，跳过耦合、领域驱动设计等细节。，我们将推出一项新服务:订单服务。这是一项关键服务，业务部门希望比应用程序的其他部分更频繁地对其进行更改，并且具有相当复杂的写入模型。我们也可以用这个模型探索建筑模式，比如 CQRS，但是我跑题了。

我们希望根据后端的现有实现来关注订单服务的边界和 API。实际上，这种实现更可能是对现有代码的重写，而不是移植，但是这里的思想/方法是一样的。注意，在这个架构中，订单服务有自己的数据库。这很好；我们的目标是完全脱钩。然而，我们还没有到那一步。我们还需要考虑/采取几个步骤。

这一步也是一个很好的时机，通过关注它可能发出或消费的*事件*来考虑这个服务在整个服务架构中如何发挥作用。现在是执行诸如事件风暴之类的活动的好时机，并且在我们开始处理事务性工作负载时，仔细考虑我们应该发布的事件。当我们试图与其他系统集成时，甚至当我们发展 monolith 时，这些事件都会派上用场。

*   我们希望关注我们提取的服务的 API 设计/边界。
*   这可能是对存在于巨石柱中的重写。
*   一旦我们决定了 API，我们将为服务实现一个简单的脚手架/占位符。
*   新的订单服务将有自己的数据库。
*   新的订单服务**此时将不会接受任何类型的流量。**

#### **将 API 与实现连接起来**

在这一点上，我们应该继续发展服务的 API 和领域模型，以及如何在代码中实现它。该服务会将任何新的事务性工作负载存储到自己的数据库中，并将其与任何其他服务分开。任何需要访问这些数据的服务都必须通过 API。

有一点我们不能忽视:我们的新服务及其数据与 monolith 中的数据密切相关(如果在某些方面不完全相同的话)。实际上，这非常不方便:当我们开始构建新服务时，我们将需要来自后端服务数据库的现有数据。由于数据模型中的规范化/FK 约束/关系，这可能变得非常棘手。在 monolith/backend 上重用现有的 API 可能太粗粒度了，我们将不得不重新发明大量的体操来以我们想要的形式获得数据。

我们想要做的是通过一个低级别的 API 以只读模式从后端访问数据，并有一种方法将数据/数据模型塑造成更适合我们新服务中的域模型的模型。在这个架构中，我们将临时直接连接到后端数据库，并在需要时直接查询数据。对于这一步，我们需要一个反映直接数据库访问的一致性模型。

你们中的一些人最初可能会对这种方法感到畏缩。你应该这么做。然而，简单的事实是这种方法是完全有效的，并且已经成功地用于高度关键的系统中——更重要的是，这不是最终状态架构(如果你认为这可能最终成为最终状态架构， **stop** 和**不会这样做**)。您可能还会指出，连接到后端数据库、查询数据并将其整理成我们新服务的域模型所需的正确形状，这涉及到许多讨厌的集成/样板文件。我认为，由于这在我们的整体进化中是暂时的，它可能是好的:也就是说，利用你的技术债务优势，然后迅速偿还。但是，有更好的办法。我将在这篇博文的第 2 部分讨论这个问题。

或者，你们中的一些人可能会说，“那么，就在后端数据库前建立一个 REST API，它提供底层数据访问，并让新服务调用它。”这也是一种可行的方法，但也有缺点。同样，我将在第 2 部分对此进行更详细的讨论。

**注意事项**

*   提取的/新的服务有一个数据模型，根据定义，它与 monolith 的数据模型紧密耦合。
*   monolith 很可能没有提供合适级别的 API 来获取这些数据。
*   即使我们得到了数据，也需要大量样板代码来对数据进行整形。
*   我们可以暂时直接连接到后端数据库进行只读查询。
*   巨石柱很少(如果有的话)改变它的数据库。

#### **开始向新服务发送影子流量(黑暗启动)**

在这种方法/模式的下一步中，我们需要一种方法将流量真正导向我们的新服务。然而，我们不想做一个大爆炸式的发布。我们不希望仅仅将这一点投入到我们的生产流量中(特别是考虑到这个例子使用了接受订单的“订单”服务！我们不想介绍任何关于接受订单的问题！).虽然我们不能轻易改变底层的 monolith 数据库，但如果有希望的话，你可以对 monolith 应用程序进行修改，以调用我们的新订单服务。如果你不确定如何做到最好，我强烈推荐 [Michael Feather 的《有效地使用遗留代码》](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)。有一些模式，比如 Sprout 方法/类和/或 Wrap 方法/类会有所帮助。

当我们对我们的 monolith/backend 进行更改时，我们不想替换旧的代码路径。我们希望放入足够的代码来允许旧的或新的代码路径运行，甚至可能并行运行。理想情况下，新版本的 monolith 在运行时允许我们控制是否发送到新的订单服务、旧的 monolith 代码路径或者两者都发送。在调用路径的任何组合中，我们都希望进行大量的检测，以了解新旧执行路径之间的任何潜在偏差。

另一件要注意的事情是:如果我们允许 monolith 将执行发送到旧的代码路径，同时调用我们的新服务，我们需要一种方法来将这个事务/对新服务的调用标记为“合成”调用。如果您的新服务不如本例中的订单服务重要，并且您可以处理副本，那么这个合成请求标识可能就不那么重要了。如果您的新服务倾向于提供更多的只读流量，那么您可能不太担心识别合成事务。然而，在合成事务的情况下，您希望能够端到端地运行整个服务，包括存储到数据库中。您可以在这里选择使用“合成”标志存储数据，或者回滚事务(如果您的数据存储支持的话)。

![](../Images/be85f10dcfce5099823de473ebd3afd4.png)这里要注意的最后一件事是，当我们对 monolith/backend 进行更改时，我们再次希望使用[黑暗启动/金丝雀/滚动释放](http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/)方法。我们将需要我们的基础设施来支持这一点。我们将在第二部分对此进行更深入的探讨。

在这一点上，我们迫使交通通过巨石。我们试图尽可能不干扰主调用流，这样我们可以在[金丝雀](http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/)不顺利的情况下快速回滚。另一方面，部署一个网关/控制组件可能是有用的，它可以更好地控制对新服务的调用，而不是强制调用。在这种情况下，网关将拥有控制逻辑，以决定是将事务发送给整体、新服务还是两者都发送。

**注意事项**

*   将新订单服务引入代码路径会带来风险。
*   我们需要以可控的方式向新服务发送流量。
*   我们希望能够将流量导向新的服务以及旧的代码路径。
*   我们需要检测和监控新服务的影响。
*   我们需要将事务标记为“合成”的方法，这样我们就不会陷入令人讨厌的业务一致性问题。
*   我们希望将这一新功能部署到某些群组/群体/用户。

#### **金丝雀/滚动发布新服务**

![](../Images/98d2a2b1d398eea2e6f71a04207aec4c.png)如果我们发现上一步没有对我们的交易路径产生负面影响，并且通过我们在生产中对流量进行跟踪的测试和初步实验，我们有很高的信心，我们可以配置 monolith 以实际将流量发送到新服务。在这种情况下，我们需要能够指定某些群组/组/用户始终使用新的服务，我们正在慢慢地消耗通过旧代码路径的实际生产流量。我们可以增加后端服务的滚动发布，直到所有用户都使用新订单微服务。

我们需要具体说明的一个风险点是:一旦我们开始将实时流量(非影子/合成流量)转移到新服务，我们就希望与群组匹配的用户总是使用这项新服务。我们不能在新旧代码路径之间来回切换。在这种情况下，如果我们确实需要回滚，这将涉及更多的协调，以便将新服务中的任何新事务移回到旧服务可以使用的状态。希望这不会发生，但这是值得注意和计划的事情(和测试！).

**注意事项**

*   我们可以识别群组，并向我们的新微服务发送实时交易流量。
*   我们仍然需要与 monolith 的直接数据库连接，因为在一段时间内，事务仍然会在两个代码路径上进行。
*   一旦我们将所有流量转移到我们的微服务，我们就应该可以淘汰旧功能了。
*   请注意，一旦我们将实时流量发送到新服务，我们必须考虑这样一个事实，即回滚到旧代码路径将涉及一些困难和协调。

#### **离线数据 ETL/迁移**

![](../Images/6201246374bb3bcabc1498575ccad254.png)此时，我们应该让订单微服务实时处理生产流量。monolith 或后端仍在处理其他问题，但我们已经成功地将服务功能迁移出 Monolith。当我们在新的微服务和后端服务之间创建一个直接的数据库连接时，我们现在迫切关注的是偿还我们所借的技术债务。这很可能涉及到从 monolith 数据库到新服务的某种一次性 ETL。可能要求 monolith 仍然以只读模式保存数据(想想:法规遵从性，等等)。).如果这是共享参考数据(即只读)，这应该没问题。我们必须确保 monolith 中的数据和新微服务中的数据不是一些共享的/可变的数据。如果数据是共享的/可变的，那么我们可能会陷入不同的数据/数据所有权问题。

**注意事项**

*   我们的新订单微服务现在正处于完全自主化的最后挣扎中。
*   当我们将订单服务数据库连接到后端时，我们需要偿还我们借来的技术债务
*   我们将对应该保存在订单中的数据进行一次性 ETL
*   我们需要注意不同的数据问题。

#### **断开/分离数据存储库**

![](../Images/c79047e09cbca832d14167bbda015bb8.png)完成上一步后，我们的新订单应该独立于微服务，并准备好参与服务架构。这里介绍的步骤都有各自的考虑因素和利弊。我们应该致力于满足所有的步骤，而不是让技术债务产生利息。当然，这种模式还会有变化，但是这种方法是合理的。

在下一篇博文中，我将展示如何使用我之前提到的示例服务来完成这些步骤，并更深入地挖掘一些有助于提供帮助的工具、框架和基础设施。我们将关注诸如 Kubernetes T1、T2、Istio T3、特征标志框架、数据视图工具和测试框架。

第 2 部分将在 12 月发布

在推特上关注( [@christianposta](https://www.twitter.com/christianposta) )或【http://blog.christianposta.com】T2 了解最新的更新和讨论。

— [克里斯蒂安·波斯塔](https://devops.com/author/christian-posta/)