# 最大值和最小值:不干涉素数指令(用于可见性)

> 原文:[https://devo PS . com/of-max-and-min-the-non-interference-prime-directive-for-visibility/](https://devops.com/of-max-and-min-the-non-interference-prime-directive-for-visibility/)

[上一期](https://devops.com/of-max-and-min-when-performance-engineering-plans-go-awry/) ，我引用 CPU 利用率作为一个经常被误用来描述/解释/推断系统性能的指标的例子，并断言提高可见性有助于克服这种误用。在这一期中，我将详细阐述改进可见性的含义，并展示两个案例研究，说明我在可见性中注意到的最近的反模式:*I*T6】由可见性接口引起的干扰。

我将用一些现实世界的类比来描述*理想*可见性接口的一些属性。结合两个源于*干扰监控接口*的性能问题的案例研究，我将解释为什么*干扰*会对[可观测性](https://devops.com/?s=observability)工作造成如此大的破坏。因为很少有库和应用程序通过*理想的*接口提供可见性，所以我也继续为我们的操作系统提供更好的可见性原语。

## 澄清可见性

在 DevOps 和 SRE 社区，可观察性是一件大事。如果不了解系统的状态，我们就无法知道系统运行得有多好。与《星际迷航》中的 Scotty 不同，我们绝对不应该依靠直觉来判断驱动我们企业系统的引擎的健康状况。我们必须建立我们的系统，使他们的内部状态对外界可见。

但不常讨论的是可见性的*度*以及相关成本。系统的*可见性*不是一个二元的“是/否”属性。正如在物理世界中一样，可见性的一些特性会影响系统的实际可观测性:

*   可见性*是连续的*还是*离散的*(在时间或空间上)？
*   观察的行为会扰乱系统吗？
*   每个人都能观察到还是只有少数代理人能观察到并向其他所有人报告？
    *   大家可以同时观察还是一个一个来？

让我们通过查看物理世界中的一些例子来为*可见性*的这些属性打下基础。在这个系列的第一篇文章中，我提到了在性能工程中缺乏标准化的语言。据我所知，围绕可见性的属性没有标准化的语言，所以我使用的形容词绝不是“标准的”——但它们所确定的区别是重要的。

## 连续与离散可见性

在伦敦时，如果我能看到大本钟的四张面孔中的一张，我只要抬头就能知道现在是什么时间。我可以随时访问时间。但是如果我看不到任何一张脸，我仍然可以依靠钟声——只不过钟声每 15 分钟才响一次。这意味着，如果我看不到大本钟的四个面孔中的任何一个，我对一天中时间的访问将是离散的。

如果我目睹了一场事故，对时间的连续访问允许我精确地记下事故发生的时间。如果我不得不依靠钟声，我归因于事故的时间就变得不那么精确了。

同样，在我们的汽车中，我们经常需要知道我们当前的速度是多少(例如，当我们接近速度陷阱或进入学校区时)。如果我们的速度计以五分钟的快照报告我们的速度，那将是完全无用的。我不想知道三分钟前我开得有多快。我需要知道我现在开得有多快！

在其他条件相同的情况下，持续可见性更好。能够根据需要检查系统的状态远比必须等待某个任意的时间间隔之后信息才可用要好得多——除非实时检查系统状态的成本过高。

## 开销、干扰和多观众竞争

测量开销可能是大多数人熟悉的成本类型，也是我们许多人关注的测量成本类型。放下尺子测量一张纸的尺寸所花费的时间，或者进行进程间通信调用以获取服务状态所花费的时间，都是与测量相关的成本。当然，我们希望这种测量开销尽可能低，但是我们有时可以忍受开销，因为开销大部分由观察者承担。

然后是干扰被测系统运行的测量。比如参加我们医生推荐的年度体检。这些检查的目的是测量我们身体的状态，以检测健康退化。相当重要的东西。但是这些考试是侵入性的。我们不得不从工作中抽出时间，打破我们的日常惯例，跋涉到医生的办公室去接受检查和刺激。有些人甚至跳过年刊，因为这对他们的生活有太大的干扰。消费医疗设备的许多令人兴奋的进步本质上促进了对生命体征的更连续监测，因此我们可以越来越少地依赖这些侵入性的年度体检。还是那句话，持续可见优先！

在计算机系统中，实际上不可能进行不与目标软件争夺硬件资源的基于软件的测量。因此，在软件中实现可见性意味着一些干扰是不可避免的。但是，争夺像软件锁和关键区域这样的软件资源完全是另一回事。因此，我们在为可见性设计系统时，必须认识到软件资源的竞争。这是能见度的*不干涉主指令的本质。*

* * *

| **来自 PMWG 的互不干涉主要指令**业绩管理工作组(PMWG)的参与者有不同的目标和优先事项。我的首要任务是为操作系统和过程度量建立一个最小干扰的低级可见性接口。这就成为了 [通用测量架构规范](https://pubs.opengroup.org/onlinepubs/9657299/toc.pdf) 中的数据捕获接口(DCI)层。DCI 的一个关键部分包括了关于监控的性能影响的陈述:***1.2.2 性能******任何指标采集子系统的添加都不应明显影响被测系统的性能。(许多性能工具构建者断言，当有测量活动时，系统性能的改变不应该超过 5%。)虽然规定性能降级数字超出了本规范的范围，但该数字属于实现的设计规范，性能目标确实要求本文档中指定的编程接口能够在目标操作系统上以最有效的方式实现。*T3】**我实际上想要比规范中关于性能影响的一般声明更强的东西，并且认为我们应该提供一个参考实现，它将体现低开销、低干扰和低争用的关键原则。为此，我制作了一个 UNIX SVR4 的原型，其中 sar/sadc 实用程序使用的内核 sysinfo 数据结构被放在内核地址空间的页面对齐区域。我还确保页面的其余部分没有被任何其他数据占用(以解决安全问题)，并在内核地址空间中安排该页面，该页面通常受到保护，不会被用户空间的读写操作所影响，所有用户进程在用户地址空间中的固定地址都可以读取(但仍然不可写)(这是一个演示“事情可能如何”的原型)。SADC(sar 的数据收集组件)通常通过/dev/kmem(一个特殊的文件，为内核虚拟地址空间提供文件访问语义)访问 sysinfo 数据结构。在我的原型系统上，我修改了 sadc，简单地取消了 sysinfo 所在的固定虚拟内存的引用。没有 open、lseek 和 read—只有内存解引用。在我的原型运行的 3B2/400 系统上，每秒钟运行一次 sadc 通常会占用单个 CPU 的近 5%。在我的原型系统上，我能够每秒钟运行 sadc 100 次，几乎没有可测量的 CPU 使用率。此外，在我的原型中，每个进程通过简单的内存解引用对 sysinfo 数据进行只读访问。该系统变得超级可见——几乎没有开销。每个人都可以在任何时候查看 sysinfo，代价是内存访问。能见度涅槃！唉，涅槃 nixed 失乐园。PMWG 参与者不希望将参考实现的要求强加给他们的内核开发人员。相反，我们选择了您在上面看到的关于*性能*的较弱陈述。 |

* * *

正如年度体检一样，导致系统变慢的计算机系统测量实施对进行该测量产生了巨大的抑制作用。 ² 测量干扰是我们需要从实施中设计出来的东西，而不是设计到实施中。

例如，如果一个系统维护一个正在被添加和删除的对象的链表，并且这个链表的遍历和操作受到读写锁的保护，那么需要以只读方式遍历这个对象集合的监控接口的实现*不应该*参与这个锁定协议。这种说法可能会激怒一些习惯于“不惜一切代价保持数据完整性”的软件工程师，但这突出了一般软件工程和性能工程的实际需求之间的一些优先级差异。 ³ 实施导致软件干扰的监控界面会适得其反——它们在最需要的时候无法使用。

到目前为止，我们只考虑了我们系统的单个观察者。当有多个观察者时，我们还要问观察者之间是否互相干扰。现实生活中有很多这样的例子。例如，如果十个人试图测量一张纸的尺寸，物理约束可能只允许一次进行两次或四次测量(最多)(即，假设参与者测量宽度，然后测量高度的有组织的流水线)。序列化观察者访问的一个更现实的例子可能是游轮下层甲板上的舷窗。一些较小的舷窗一次只能让一个人看到外面。因此，当一群鲸鱼游过时，观众必须排队，轮流进入才能观察它们。

在计算机系统中，多个观察者之间的测量争用也会阻碍观察——不是因为每个人都很有礼貌，而是因为没有人愿意排队。

## 分散的与整体的可见性

可见度的最后一个方面与视野有关。在现实世界中，这是通过比较游轮内部的舷窗视图和顶层甲板上开阔、无障碍的视图来说明的。与顶层甲板相比，舷窗只能看到海洋的一部分。人们有时需要将来自多个窗口的视图拼接在一起，以获得外部世界的更完整视图。更完整的视图的重要性在于固有的更大的画面——其中每个片段提供了相邻片段的上下文。

在计算机系统中，可见性本质上是不完整的。每个组件都提供了一个(或没有)进入其自身状态的可见性门户。就像游轮下层甲板上的舷窗一样，如果我们能够以合理及时的方式查询每个组件的状态，我们就可以近似获得一个整体视图。同样，只有当每个组件都支持连续可见性时，这才是可能的。不幸的是:

*   许多关键的低级组件不提供*任何*可见性。
*   许多其他组件仅提供离散可见性。
*   有些甚至进一步限制了可见性，通过网络套接字与脱离主机的端点提供离散的可见性。因此，协同定位的组件无法以任何实际的方式检查彼此的可见性接口。

反过来，许多组件中不连续的可见性所导致的不透明、不完整的视图导致了开发人员的不完整心态。工程师形成了一种思维模式，他们只为自己和他们的组件实现可见性，而不是将他们的可见性视为整体的一部分——这为证明他们所依赖的离散视图的合理性提供了循环论证。

不要想象游轮和舷窗上的乘客，而是想象作为工厂工人在主机上共同执行的组件——数据在它们之间移动。当前的分散视图将每个工作人员置于他们自己的房间中，在那里他们无法看到其他工作人员的状态。通过对邻居的持续了解，员工可以获得全局视图，从而制定更好的计划和决策。“工厂监视器”可以获得更全面的事件视图，并更好地关联不同组件的状态。能够围绕观察构建有用的上下文是可观察性的一个关键属性。

相比之下，现代 UNIX 和 Linux 系统通过/proc 接口支持操作系统和进程指标的连续可见性。我们可以随时查询/处理支持的指标。/proc 接口的效用(和成功)是毋庸置疑的——能够通过文件系统名称空间访问进程和系统指标是一个很棒的想法。 ⁵

应用程序和库已经习惯了随意查询标准系统指标的能力。如果这种持续可见的模式扩展到整个堆栈，那么生态系统将从这种增强的可观测性中受益，这是显而易见的。这将推动操作系统提供原语，以促进整个堆栈的持续可见性。

但是在我们等待可见性涅槃的时候，有一些实际问题需要解决。目前存在的一些重要的可见性接口在很大程度上违反了 prime 指令。

## 违反主要指令

我在 SRECon 2021 上发表了题为 [*延迟分布和微基准测试以识别和表征内核热点*](https://www.usenix.org/conference/srecon21/presentation/chen) 的演讲，其中两个热点案例研究是违反无干扰 Prime 指令的标准、常用可见性接口的示例。让我们检查这两个案例。

## 当运行 Netstat 的成本太高时

我们最近发现，netstat 会严重延迟 Solaris 上 UNIX 域子系统(UDS)套接字的创建和销毁。更具体地说，在 Solaris 中，查询所有活动 UDS 套接字列表的 kstat 机制(一个 ioctl 调用)可能需要几秒钟的 CPU 时间，尤其是当系统中有数万个套接字时。就其本身而言，这是有逻辑意义的，并且不是问题，因为更多的套接字意味着更多的数据从内核传输到用户空间。但是长时间的 netstat 运行对实际 UDS 套接字创建和销毁的影响是令人惊讶的(也是令人失望的)。

下面是我编写的程序 的输出，它收集了在 Solaris 11.3 系统上创建和销毁 UDS 套接字 100K 次的套接字()和关闭()时间的对数直方图:

|  | < 1us | < 10 美元 | < 100 美元 | < 1 毫秒 | 小于 10 毫秒 | < 100 毫秒 | < 1 秒 | > 1 秒 | 最大 |
| (电源)插座 | Zero | Zero | Seventy-two thousand five hundred and fifty-six | Twenty-seven thousand four hundred and thirty-three | Eleven | Zero | Zero | Zero | 1967055 纳秒 |
| 关闭 | Zero | Ninety-eight thousand two hundred and sixty-two | Nine hundred and seven | Eight hundred and fifteen | Sixteen | Zero | Zero | Zero | 1364475 纳秒 |

现在，这里是同一个程序的结果，但是这次我同时运行了 netstat -f unix 的一个实例:

|  | < 1us | < 10 美元 | < 100 美元 | < 1 毫秒 | 小于 10 毫秒 | < 100 毫秒 | < 1 秒 | > 1 秒 | 最大 |
| (电源)插座 | Zero | Zero | Thirty-nine thousand and six | Sixty thousand nine hundred and seventy-six | Eighteen | Zero | Zero | Zero | 2137995ns |
| 关闭 | Zero | Ninety-six thousand eight hundred and thirty-seven | One thousand three hundred and eighty-eight | One thousand seven hundred and fifty-seven | Fifteen | Two | one | Zero | 308073600 纳秒 |

看看单个 netstat 调用是如何将最大关闭时间从大约 1 毫秒提高到超过 3 秒的！ ⁶ 看起来，聚集在 10-100 微秒范围内的 socket()时间分布已经增加到更聚集在 0.1-1 毫秒范围内。运行 netstat 的行为对创建和关闭 UDS 套接字的时间有巨大的*影响。*

禁用 netstat 不是正确的长期解决方案，因为这样做会消除关键可见性。人为限制 netstat 的使用也不是正确的长期解决方案，因为这会损害可见性的及时性(即连续可见性)。正确的做法是消除 netstat 监控和 UDS 之间的紧密耦合。

## 当 PS 代表“相当慢”时

在 Linux 爱好者自鸣得意地认为监控干扰只是 Solaris 的问题之前，Linux 上可能存在一个更大的问题。这里，监控争用是通过访问/proc 本身看到的，属于“争用观察者”类型。

让我们来看看在我们的一个具有 36 个内核和 72 个硬件线程的 Linux 开发平台(RHEL 7.6)上运行“ps auxww”的并发实例:

| 并发 | 墙壁时间(平均) | 用户时间 | 系统时间 |
| one | .984 | .081 | .902 |
| Two | One point two six nine | .071 | One point zero one three |
| four | Three point zero four three | .066 | One point four two nine |
| eight | Four point one zero six | .070 | One point three nine six |

正如我们所看到的，随着并发性的增加，ps 完成的平均时间也增加了(系统 CPU 时间也增加了)。ps 实例相互竞争！这更令人惊讶，因为 ps 本质上是一个只读操作。

进一步的测试表明，进程和线程的/proc 遍历不仅相互竞争，而且它们还竞争对/proc 下其他与进程无关的特殊文件的访问(例如/proc/vmstat)。这一点非常重要，因为许多库和应用程序依赖/proc 提供的非进程数据来做出运行时决策。

我的同事加里·李库将在 10 月下旬的 EMEA 大会上发表关于这个/proc 争用问题的更多发现。

## 发生了什么事？

在过去，像 ps 和 netstat 这样的工具通过打开特殊的文件/dev/kmem 来获取数据——这是一个基于文件的内核虚拟地址空间接口。如果我们知道一个对象的虚拟地址和它的大小，我们可以简单地在文件中查找虚拟地址并读取()该对象。这种读取的解耦性质意味着不可能与操作对象的实际代码进行任何同步或协调。对象可能会在读取过程中发生变化。如前所述，对监控数据一致性的期望可能比大多数软件工程师处理的标准数据流要宽松。这种解耦的数据访问遵循了无干扰原则，非常适合监控用例。

在现代 UNIX 系统中,/dev/kmem 的使用已经失宠——这是有充分理由的。除了访问内核对象的查找/读取的性能开销之外，/dev/kmem 还提供了对整个内核虚拟地址空间的全有或全无的访问。这意味着通过/dev/kmem 进行监控的应用程序也必须以提升的权限受到信任。

在许多 UNIX 和 Linux 系统上，通过/dev/kmem 的通用解耦访问已经被通过接口(如/proc)对内核对象的(潜在)耦合访问所取代。但是，正如我们得出的结论，仅仅因为耦合接入是允许的，并不意味着它应该在不考虑干扰成本的情况下实施。

假设一个可见性接口很少或很少被使用，这通常是一个糟糕的假设。可见性界面越有用，使用的频率就越高。

## 用户空间中的可见性

如前所述，虽然操作系统为访问众所周知的系统和流程指标提供了连续的可见性接口(例如/proc ),但应用程序代码通常不提供。可以说，通过避免连续可见性接口，应用程序也能够避免干扰和观察者争用的问题——这将是一个有效的论点。但是，我觉得系统的协同定位组件的整体视图的理想是如此令人信服，以至于应用程序应该(1)游说操作系统为应用程序提供适当的连续可见性原语(/proc 为构建这种原语提供了一个极好的框架)或者(2)实现它们自己的连续可见性接口。 ⁹

Java 和 JVM 提供了连续可见性接口如何在用户空间中工作的例子。很早以前，Java 的设计者就看到了 JVM 持续可见性的好处，并提出了 Java 管理扩展(JMX)框架。通过这个框架，JVM、Java 库和 Java 应用程序能够通过*管理 bean*上的 getters 公开指标。这些 getters 可以通过一个公共名称空间来发现。JMX 还允许外部客户端通过标准化的远程过程调用机制来调用这些 getters。

getter 可以简单地实现为返回总结代码状态的对象的当前值，或者用任意复杂的代码实现——包括调用其他管理 beans 上的 getter 或查询远程数据库。但是，前面概述的开销和无干扰问题应该适用于为实现性能可见性而实现的 getters。

最后，有趣的是，Oracle(可能还有其他)JVM 也实现了一种低级指标公开机制，该机制利用内存映射文件为 JVM 元数据和一些低级指标提供共享内存接口。即使有了 JMX 提供的连续可见性，JVM 也认识到了利用共享内存的低开销、更解耦、免协调可见性的优势。

我们都应该牢记首要指令，并以最少干扰、最少耦合的实用方式设计我们的可见性机制。或者作为用户，要求我们使用的可见性机制遵守主要指令。

* * *

¹ 是的，我知道；大本钟实际上并不是那个钟面塔的名字:https://en.wikipedia.org/wiki/Big_Ben

² 这些实现并非一无是处。但是它们通常被归入用于性能调试——通常在非生产环境中。

在构建松散耦合的分布式系统时，也要采取类似的妥协——尤其是在最终一致性是可接受的标准的超大型系统中。我们需要将监控系统的设计视为与被观察的系统松散耦合。

⁴ 虽然最近来自认知神经科学的见解认为，这种完整的视觉视图实际上是我们大脑创造的一种错觉:[](https://www.science.org/doi/10.1126/sciadv.abk2480)。但是对系统状态的准确整体观点的概念仍然是一个理想的目标。

不幸的是，还没有人选择实现一个低成本、低干扰、低竞争的机制，就像我为 UNIX SVR4 设计的原型一样。

⁶The netstat 对 UDS 套接字创建和关闭的影响大小是系统上 UDS 套接字数量的函数。UDS 套接字越多，影响越大。

⁷ 随着系统中轻量级进程/线程数量的增加，这种行为变得更加明显，因为开销似乎呈二次方增长。

我的内存访问原型比/dev/kmem 的读取成本低几个数量级，也以类似的方式解耦。

无论我走到哪里，我都会重新实现我的 libmetrix C 库——通过内存映射文件进行指标注册和公开，这接近于我认为基于/proc 的理想指标原语。用户级库和应用程序的理想度量注册和公开接口应该在 /proc 下实现。

^(10) 精神上类似于我前面提到的 libmetrix 库。

***感谢***

再次感谢对本文早期草稿提供反馈的所有人。再次特别感谢 Peter Wainwright，他帮助我更好地组织了本期文章的思路。